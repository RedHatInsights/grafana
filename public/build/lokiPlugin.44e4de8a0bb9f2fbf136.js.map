{"version":3,"file":"lokiPlugin.44e4de8a0bb9f2fbf136.js","mappings":"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","sources":["webpack://grafana/./public/app/plugins/datasource/loki/add_label_to_query.ts","webpack://grafana/./.yarn/cache/uuid-npm-8.3.0-2f98335399-b539886e6a.zip/node_modules/uuid/dist/esm-browser/parse.js","webpack://grafana/./.yarn/cache/uuid-npm-8.3.0-2f98335399-b539886e6a.zip/node_modules/uuid/dist/esm-browser/sha1.js","webpack://grafana/./.yarn/cache/uuid-npm-8.3.0-2f98335399-b539886e6a.zip/node_modules/uuid/dist/esm-browser/v5.js","webpack://grafana/./.yarn/cache/uuid-npm-8.3.0-2f98335399-b539886e6a.zip/node_modules/uuid/dist/esm-browser/v35.js","webpack://grafana/./public/app/plugins/datasource/loki/query_utils.ts","webpack://grafana/./public/app/plugins/datasource/loki/types.ts","webpack://grafana/./public/app/plugins/datasource/loki/result_transformer.ts","webpack://grafana/./.yarn/cache/rxjs-npm-7.3.0-8a14d1c3d9-e63adb8808.zip/node_modules/rxjs/dist/esm5/internal/observable/dom/WebSocketSubject.js","webpack://grafana/./public/app/plugins/datasource/loki/live_streams.ts","webpack://grafana/./.yarn/cache/rxjs-npm-7.3.0-8a14d1c3d9-e63adb8808.zip/node_modules/rxjs/dist/esm5/internal/observable/dom/webSocket.js","webpack://grafana/./public/app/plugins/datasource/loki/language_provider.ts","webpack://grafana/./public/app/plugins/datasource/loki/datasource.ts","webpack://grafana/./public/app/plugins/datasource/loki/components/LokiCheatSheet.tsx","webpack://grafana/./public/app/plugins/datasource/loki/components/LokiExploreQueryEditor.tsx","webpack://grafana/./public/app/plugins/datasource/loki/components/LokiQueryEditor.tsx","webpack://grafana/./public/app/plugins/datasource/loki/components/LokiQueryEditorForAlerting.tsx","webpack://grafana/./public/app/plugins/datasource/loki/components/LokiQueryEditorByApp.tsx","webpack://grafana/./public/app/plugins/datasource/loki/LokiAnnotationsQueryCtrl.tsx","webpack://grafana/./public/app/plugins/datasource/loki/configuration/MaxLinesField.tsx","webpack://grafana/./public/app/plugins/datasource/loki/configuration/DerivedField.tsx","webpack://grafana/./public/app/plugins/datasource/loki/configuration/DebugSection.tsx","webpack://grafana/./public/app/plugins/datasource/loki/configuration/DerivedFields.tsx","webpack://grafana/./public/app/plugins/datasource/loki/configuration/ConfigEditor.tsx","webpack://grafana/./public/app/plugins/datasource/loki/module.ts"],"sourcesContent":["import { chain, isEqual } from 'lodash';\nimport { LOKI_KEYWORDS } from './syntax';\nimport { PROM_KEYWORDS, OPERATORS, LOGICAL_OPERATORS } from 'app/plugins/datasource/prometheus/promql';\n\nconst builtInWords = [...PROM_KEYWORDS, ...OPERATORS, ...LOGICAL_OPERATORS, ...LOKI_KEYWORDS];\n\n// We want to extract all possible metrics and also keywords\nconst metricsAndKeywordsRegexp = /([A-Za-z:][\\w:]*)\\b(?![\\]{=!\",])/g;\n\nexport function addLabelToQuery(\n  query: string,\n  key: string,\n  value: string | number,\n  operator?: string,\n  hasNoMetrics?: boolean\n): string {\n  if (!key || !value) {\n    throw new Error('Need label to add to query.');\n  }\n\n  // We need to make sure that we convert the value back to string because it may be a number\n  const transformedValue = value === Infinity ? '+Inf' : value.toString();\n\n  // Add empty selectors to bare metric names\n  let previousWord: string;\n\n  query = query.replace(metricsAndKeywordsRegexp, (match, word, offset) => {\n    const isMetric = isWordMetric(query, word, offset, previousWord, hasNoMetrics);\n    previousWord = word;\n\n    return isMetric ? `${word}{}` : word;\n  });\n\n  //This is a RegExp for stream selector - e.g. {job=\"grafana\"}\n  const selectorRegexp = /(\\$)?{([^{]*)}/g;\n  const parts = [];\n  let lastIndex = 0;\n  let suffix = '';\n\n  let match = selectorRegexp.exec(query);\n  /* \n    There are 2 possible false positive scenarios: \n    \n    1. We match Grafana's variables with ${ syntax - such as${__rate_s}. To filter these out we could use negative lookbehind,\n    but Safari browser currently doesn't support it. Therefore we need to hack this by creating 2 matching groups. \n    (\\$) is for the Grafana's variables and if we match it, we know this is not a stream selector and we don't want to add label.\n\n    2. Log queries can include {{.label}} syntax when line_format is used. We need to filter these out by checking\n    if match starts with \"{.\"\n  */\n  while (match) {\n    const prefix = query.slice(lastIndex, match.index);\n    lastIndex = match.index + match[2].length + 2;\n    suffix = query.slice(match.index + match[0].length);\n\n    // Filtering our false positives\n    if (match[0].startsWith('{.') || match[1]) {\n      parts.push(prefix);\n      parts.push(match[0]);\n    } else {\n      // If we didn't match first group, we are inside selector and we want to add labels\n      const selector = match[2];\n      const selectorWithLabel = addLabelToSelector(selector, key, transformedValue, operator);\n      parts.push(prefix, selectorWithLabel);\n    }\n\n    match = selectorRegexp.exec(query);\n  }\n\n  parts.push(suffix);\n  return parts.join('');\n}\n\nconst labelRegexp = /(\\w+)\\s*(=|!=|=~|!~)\\s*(\"[^\"]*\")/g;\n\nexport function addLabelToSelector(selector: string, labelKey: string, labelValue: string, labelOperator?: string) {\n  const parsedLabels = [];\n\n  // Split selector into labels\n  if (selector) {\n    let match = labelRegexp.exec(selector);\n    while (match) {\n      parsedLabels.push({ key: match[1], operator: match[2], value: match[3] });\n      match = labelRegexp.exec(selector);\n    }\n  }\n\n  // Add new label\n  const operatorForLabelKey = labelOperator || '=';\n  parsedLabels.push({ key: labelKey, operator: operatorForLabelKey, value: `\"${labelValue}\"` });\n\n  // Sort labels by key and put them together\n  const formatted = chain(parsedLabels)\n    .uniqWith(isEqual)\n    .compact()\n    .sortBy('key')\n    .map(({ key, operator, value }) => `${key}${operator}${value}`)\n    .value()\n    .join(',');\n\n  return `{${formatted}}`;\n}\n\nfunction isPositionInsideChars(text: string, position: number, openChar: string, closeChar: string) {\n  const nextSelectorStart = text.slice(position).indexOf(openChar);\n  const nextSelectorEnd = text.slice(position).indexOf(closeChar);\n  return nextSelectorEnd > -1 && (nextSelectorStart === -1 || nextSelectorStart > nextSelectorEnd);\n}\n\nfunction isWordMetric(query: string, word: string, offset: number, previousWord: string, hasNoMetrics?: boolean) {\n  const insideSelector = isPositionInsideChars(query, offset, '{', '}');\n  // Handle \"sum by (key) (metric)\"\n  const previousWordIsKeyWord = previousWord && OPERATORS.indexOf(previousWord) > -1;\n  // Check for colon as as \"word boundary\" symbol\n  const isColonBounded = word.endsWith(':');\n  // Check for words that start with \" which means that they are not metrics\n  const startsWithQuote = query[offset - 1] === '\"';\n  // Check for template variables\n  const isTemplateVariable = query[offset - 1] === '$';\n  // Check for time units\n  const isTimeUnit = ['s', 'm', 'h', 'd', 'w'].includes(word) && Boolean(Number(query[offset - 1]));\n\n  if (\n    !hasNoMetrics &&\n    !insideSelector &&\n    !isColonBounded &&\n    !previousWordIsKeyWord &&\n    !startsWithQuote &&\n    !isTemplateVariable &&\n    !isTimeUnit &&\n    builtInWords.indexOf(word) === -1\n  ) {\n    return true;\n  }\n  return false;\n}\n\nexport default addLabelToQuery;\n","import validate from './validate.js';\n\nfunction parse(uuid) {\n  if (!validate(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  var v;\n  var arr = new Uint8Array(16); // Parse ########-....-....-....-............\n\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = v >>> 16 & 0xff;\n  arr[2] = v >>> 8 & 0xff;\n  arr[3] = v & 0xff; // Parse ........-####-....-....-............\n\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff; // Parse ........-....-####-....-............\n\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff; // Parse ........-....-....-####-............\n\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff; // Parse ........-....-....-....-############\n  // (Use \"/\" to avoid 32-bit truncation when bit-shifting high-order bytes)\n\n  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;\n  arr[11] = v / 0x100000000 & 0xff;\n  arr[12] = v >>> 24 & 0xff;\n  arr[13] = v >>> 16 & 0xff;\n  arr[14] = v >>> 8 & 0xff;\n  arr[15] = v & 0xff;\n  return arr;\n}\n\nexport default parse;","// Adapted from Chris Veness' SHA1 code at\n// http://www.movable-type.co.uk/scripts/sha1.html\nfunction f(s, x, y, z) {\n  switch (s) {\n    case 0:\n      return x & y ^ ~x & z;\n\n    case 1:\n      return x ^ y ^ z;\n\n    case 2:\n      return x & y ^ x & z ^ y & z;\n\n    case 3:\n      return x ^ y ^ z;\n  }\n}\n\nfunction ROTL(x, n) {\n  return x << n | x >>> 32 - n;\n}\n\nfunction sha1(bytes) {\n  var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];\n  var H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];\n\n  if (typeof bytes === 'string') {\n    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape\n\n    bytes = [];\n\n    for (var i = 0; i < msg.length; ++i) {\n      bytes.push(msg.charCodeAt(i));\n    }\n  } else if (!Array.isArray(bytes)) {\n    // Convert Array-like to Array\n    bytes = Array.prototype.slice.call(bytes);\n  }\n\n  bytes.push(0x80);\n  var l = bytes.length / 4 + 2;\n  var N = Math.ceil(l / 16);\n  var M = new Array(N);\n\n  for (var _i = 0; _i < N; ++_i) {\n    var arr = new Uint32Array(16);\n\n    for (var j = 0; j < 16; ++j) {\n      arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];\n    }\n\n    M[_i] = arr;\n  }\n\n  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);\n  M[N - 1][14] = Math.floor(M[N - 1][14]);\n  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;\n\n  for (var _i2 = 0; _i2 < N; ++_i2) {\n    var W = new Uint32Array(80);\n\n    for (var t = 0; t < 16; ++t) {\n      W[t] = M[_i2][t];\n    }\n\n    for (var _t = 16; _t < 80; ++_t) {\n      W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);\n    }\n\n    var a = H[0];\n    var b = H[1];\n    var c = H[2];\n    var d = H[3];\n    var e = H[4];\n\n    for (var _t2 = 0; _t2 < 80; ++_t2) {\n      var s = Math.floor(_t2 / 20);\n      var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;\n      e = d;\n      d = c;\n      c = ROTL(b, 30) >>> 0;\n      b = a;\n      a = T;\n    }\n\n    H[0] = H[0] + a >>> 0;\n    H[1] = H[1] + b >>> 0;\n    H[2] = H[2] + c >>> 0;\n    H[3] = H[3] + d >>> 0;\n    H[4] = H[4] + e >>> 0;\n  }\n\n  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];\n}\n\nexport default sha1;","import v35 from './v35.js';\nimport sha1 from './sha1.js';\nvar v5 = v35('v5', 0x50, sha1);\nexport default v5;","import stringify from './stringify.js';\nimport parse from './parse.js';\n\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  var bytes = [];\n\n  for (var i = 0; i < str.length; ++i) {\n    bytes.push(str.charCodeAt(i));\n  }\n\n  return bytes;\n}\n\nexport var DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nexport var URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nexport default function (name, version, hashfunc) {\n  function generateUUID(value, namespace, buf, offset) {\n    if (typeof value === 'string') {\n      value = stringToBytes(value);\n    }\n\n    if (typeof namespace === 'string') {\n      namespace = parse(namespace);\n    }\n\n    if (namespace.length !== 16) {\n      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    } // Compute hash of namespace and value, Per 4.3\n    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =\n    // hashfunc([...namespace, ... value])`\n\n\n    var bytes = new Uint8Array(16 + value.length);\n    bytes.set(namespace);\n    bytes.set(value, namespace.length);\n    bytes = hashfunc(bytes);\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n\n    if (buf) {\n      offset = offset || 0;\n\n      for (var i = 0; i < 16; ++i) {\n        buf[offset + i] = bytes[i];\n      }\n\n      return buf;\n    }\n\n    return stringify(bytes);\n  } // Function#name is not settable on some platforms (#270)\n\n\n  try {\n    generateUUID.name = name; // eslint-disable-next-line no-empty\n  } catch (err) {} // For CommonJS default export support\n\n\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}","import { escapeRegExp } from 'lodash';\nimport { PIPE_PARSERS } from './syntax';\n\nexport function formatQuery(selector: string | undefined): string {\n  return `${selector || ''}`.trim();\n}\n\n/**\n * Returns search terms from a LogQL query.\n * E.g., `{} |= foo |=bar != baz` returns `['foo', 'bar']`.\n */\nexport function getHighlighterExpressionsFromQuery(input: string): string[] {\n  let expression = input;\n  const results = [];\n\n  // Consume filter expression from left to right\n  while (expression) {\n    const filterStart = expression.search(/\\|=|\\|~|!=|!~/);\n    // Nothing more to search\n    if (filterStart === -1) {\n      break;\n    }\n    // Drop terms for negative filters\n    const filterOperator = expression.substr(filterStart, 2);\n    const skip = expression.substr(filterStart).search(/!=|!~/) === 0;\n    expression = expression.substr(filterStart + 2);\n    if (skip) {\n      continue;\n    }\n    // Check if there is more chained\n    const filterEnd = expression.search(/\\|=|\\|~|!=|!~/);\n    let filterTerm;\n    if (filterEnd === -1) {\n      filterTerm = expression.trim();\n    } else {\n      filterTerm = expression.substr(0, filterEnd).trim();\n      expression = expression.substr(filterEnd);\n    }\n\n    const quotedTerm = filterTerm.match(/\"(.*?)\"/);\n    const backtickedTerm = filterTerm.match(/`(.*?)`/);\n    const term = quotedTerm || backtickedTerm;\n\n    if (term) {\n      const unwrappedFilterTerm = term[1];\n      const regexOperator = filterOperator === '|~';\n\n      // Only filter expressions with |~ operator are treated as regular expressions\n      if (regexOperator) {\n        // When using backticks, Loki doesn't require to escape special characters and we can just push regular expression to highlights array\n        // When using quotes, we have extra backslash escaping and we need to replace \\\\ with \\\n        results.push(backtickedTerm ? unwrappedFilterTerm : unwrappedFilterTerm.replace(/\\\\\\\\/g, '\\\\'));\n      } else {\n        // We need to escape this string so it is not matched as regular expression\n        results.push(escapeRegExp(unwrappedFilterTerm));\n      }\n    } else {\n      return results;\n    }\n  }\n\n  return results;\n}\n\nexport function queryHasPipeParser(expr: string): boolean {\n  const parsers = PIPE_PARSERS.map((parser) => `${parser.label}`).join('|');\n  const regexp = new RegExp(`\\\\\\|\\\\\\s?(${parsers})`);\n  return regexp.test(expr);\n}\n\nexport function addParsedLabelToQuery(expr: string, key: string, value: string | number, operator: string) {\n  return expr + ` | ${key}${operator}\"${value.toString()}\"`;\n}\n","import { DataQuery, DataSourceJsonData, QueryResultMeta, ScopedVars } from '@grafana/data';\n\nexport interface LokiInstantQueryRequest {\n  query: string;\n  limit?: number;\n  time?: string;\n  direction?: 'BACKWARD' | 'FORWARD';\n}\n\nexport interface LokiRangeQueryRequest {\n  query: string;\n  limit?: number;\n  start?: number;\n  end?: number;\n  step?: number;\n  direction?: 'BACKWARD' | 'FORWARD';\n}\n\nexport enum LokiResultType {\n  Stream = 'streams',\n  Vector = 'vector',\n  Matrix = 'matrix',\n}\n\nexport interface LokiQuery extends DataQuery {\n  expr: string;\n  query?: string;\n  format?: string;\n  reverse?: boolean;\n  legendFormat?: string;\n  valueWithRefId?: boolean;\n  maxLines?: number;\n  resolution?: number;\n  range?: boolean;\n  instant?: boolean;\n  volumeQuery?: boolean;\n}\n\nexport interface LokiOptions extends DataSourceJsonData {\n  maxLines?: string;\n  derivedFields?: DerivedFieldConfig[];\n  alertmanager?: string;\n}\n\nexport interface LokiStats {\n  [component: string]: {\n    [label: string]: number;\n  };\n}\n\nexport interface LokiVectorResult {\n  metric: { [label: string]: string };\n  value: [number, string];\n}\n\nexport interface LokiVectorResponse {\n  status: string;\n  data: {\n    resultType: LokiResultType.Vector;\n    result: LokiVectorResult[];\n    stats?: LokiStats;\n  };\n}\n\nexport interface LokiMatrixResult {\n  metric: Record<string, string>;\n  values: Array<[number, string]>;\n}\n\nexport interface LokiMatrixResponse {\n  status: string;\n  data: {\n    resultType: LokiResultType.Matrix;\n    result: LokiMatrixResult[];\n    stats?: LokiStats;\n  };\n}\n\nexport interface LokiStreamResult {\n  stream: Record<string, string>;\n  values: Array<[string, string]>;\n}\n\nexport interface LokiStreamResponse {\n  status: string;\n  data: {\n    resultType: LokiResultType.Stream;\n    result: LokiStreamResult[];\n    stats?: LokiStats;\n  };\n}\n\nexport interface LokiTailResponse {\n  streams: LokiStreamResult[];\n  dropped_entries?: Array<{\n    labels: Record<string, string>;\n    timestamp: string;\n  }> | null;\n}\n\nexport type LokiResult = LokiVectorResult | LokiMatrixResult | LokiStreamResult;\nexport type LokiResponse = LokiVectorResponse | LokiMatrixResponse | LokiStreamResponse;\n\nexport interface LokiLogsStreamEntry {\n  line: string;\n  ts: string;\n}\n\nexport interface LokiExpression {\n  regexp: string;\n  query: string;\n}\n\nexport type DerivedFieldConfig = {\n  matcherRegex: string;\n  name: string;\n  url?: string;\n  urlDisplayLabel?: string;\n  datasourceUid?: string;\n};\n\nexport interface TransformerOptions {\n  format?: string;\n  legendFormat?: string;\n  step: number;\n  start: number;\n  end: number;\n  query: string;\n  responseListLength: number;\n  refId: string;\n  scopedVars: ScopedVars;\n  meta?: QueryResultMeta;\n  valueWithRefId?: boolean;\n}\n","import { capitalize, groupBy, isEmpty } from 'lodash';\nimport { v5 as uuidv5 } from 'uuid';\nimport { of } from 'rxjs';\n\nimport {\n  FieldType,\n  TimeSeries,\n  Labels,\n  DataFrame,\n  ArrayVector,\n  MutableDataFrame,\n  findUniqueLabels,\n  DataFrameView,\n  DataLink,\n  Field,\n  QueryResultMetaStat,\n  QueryResultMeta,\n  TimeSeriesValue,\n  ScopedVars,\n} from '@grafana/data';\n\nimport { getTemplateSrv, getDataSourceSrv } from '@grafana/runtime';\nimport TableModel from 'app/core/table_model';\nimport { formatQuery, getHighlighterExpressionsFromQuery } from './query_utils';\nimport {\n  LokiRangeQueryRequest,\n  LokiResponse,\n  LokiMatrixResult,\n  LokiVectorResult,\n  TransformerOptions,\n  LokiResultType,\n  LokiStreamResult,\n  LokiTailResponse,\n  LokiQuery,\n  LokiOptions,\n  DerivedFieldConfig,\n  LokiStreamResponse,\n  LokiStats,\n} from './types';\n\nconst UUID_NAMESPACE = '6ec946da-0f49-47a8-983a-1d76d17e7c92';\n\n/**\n * Transforms LokiStreamResult structure into a dataFrame. Used when doing standard queries and newer version of Loki.\n */\nexport function lokiStreamResultToDataFrame(stream: LokiStreamResult, reverse?: boolean, refId?: string): DataFrame {\n  const labels: Labels = stream.stream;\n  const labelsString = Object.entries(labels)\n    .map(([key, val]) => `${key}=\"${val}\"`)\n    .sort()\n    .join('');\n\n  const times = new ArrayVector<string>([]);\n  const timesNs = new ArrayVector<string>([]);\n  const lines = new ArrayVector<string>([]);\n  const uids = new ArrayVector<string>([]);\n\n  // We need to store and track all used uids to ensure that uids are unique\n  const usedUids: { string?: number } = {};\n\n  for (const [ts, line] of stream.values) {\n    // num ns epoch in string, we convert it to iso string here so it matches old format\n    times.add(new Date(parseInt(ts.substr(0, ts.length - 6), 10)).toISOString());\n    timesNs.add(ts);\n    lines.add(line);\n    uids.add(createUid(ts, labelsString, line, usedUids, refId));\n  }\n\n  return constructDataFrame(times, timesNs, lines, uids, labels, reverse, refId);\n}\n\n/**\n * Constructs dataFrame with supplied fields and other data. Also makes sure it is properly reversed if needed.\n */\nfunction constructDataFrame(\n  times: ArrayVector<string>,\n  timesNs: ArrayVector<string>,\n  lines: ArrayVector<string>,\n  uids: ArrayVector<string>,\n  labels: Labels,\n  reverse?: boolean,\n  refId?: string\n) {\n  const dataFrame = {\n    refId,\n    fields: [\n      { name: 'ts', type: FieldType.time, config: { displayName: 'Time' }, values: times }, // Time\n      { name: 'line', type: FieldType.string, config: {}, values: lines, labels }, // Line - needs to be the first field with string type\n      { name: 'id', type: FieldType.string, config: {}, values: uids },\n      { name: 'tsNs', type: FieldType.time, config: { displayName: 'Time ns' }, values: timesNs }, // Time\n    ],\n    length: times.length,\n  };\n\n  if (reverse) {\n    const mutableDataFrame = new MutableDataFrame(dataFrame);\n    mutableDataFrame.reverse();\n    return mutableDataFrame;\n  }\n\n  return dataFrame;\n}\n\n/**\n * Transform LokiResponse data and appends it to MutableDataFrame. Used for streaming where the dataFrame can be\n * a CircularDataFrame creating a fixed size rolling buffer.\n * TODO: Probably could be unified with the logStreamToDataFrame function.\n * @param response\n * @param data Needs to have ts, line, labels, id as fields\n */\nexport function appendResponseToBufferedData(response: LokiTailResponse, data: MutableDataFrame) {\n  // Should we do anything with: response.dropped_entries?\n\n  const streams: LokiStreamResult[] = response.streams;\n  if (!streams || !streams.length) {\n    return;\n  }\n\n  let baseLabels: Labels = {};\n  for (const f of data.fields) {\n    if (f.type === FieldType.string) {\n      if (f.labels) {\n        baseLabels = f.labels;\n      }\n      break;\n    }\n  }\n\n  const tsField = data.fields[0];\n  const tsNsField = data.fields[1];\n  const lineField = data.fields[2];\n  const labelsField = data.fields[3];\n  const idField = data.fields[4];\n\n  // We are comparing used ids only within the received stream. This could be a problem if the same line + labels + nanosecond timestamp came in 2 separate batches.\n  // As this is very unlikely, and the result would only affect live-tailing css animation we have decided to not compare all received uids from data param as this would slow down processing.\n  const usedUids: { string?: number } = {};\n\n  for (const stream of streams) {\n    // Find unique labels\n    const unique = findUniqueLabels(stream.stream, baseLabels);\n    const allLabelsString = Object.entries(stream.stream)\n      .map(([key, val]) => `${key}=\"${val}\"`)\n      .sort()\n      .join('');\n\n    // Add each line\n    for (const [ts, line] of stream.values) {\n      tsField.values.add(new Date(parseInt(ts.substr(0, ts.length - 6), 10)).toISOString());\n      tsNsField.values.add(ts);\n      lineField.values.add(line);\n      labelsField.values.add(unique);\n      idField.values.add(createUid(ts, allLabelsString, line, usedUids, data.refId));\n    }\n  }\n}\n\nfunction createUid(ts: string, labelsString: string, line: string, usedUids: any, refId?: string): string {\n  // Generate id as hashed nanosecond timestamp, labels and line (this does not have to be unique)\n  let id = uuidv5(`${ts}_${labelsString}_${line}`, UUID_NAMESPACE);\n\n  // Check if generated id is unique\n  // If not and we've already used it, append it's count after it\n  if (id in usedUids) {\n    // Increase the count\n    const newCount = usedUids[id] + 1;\n    usedUids[id] = newCount;\n    // Append count to generated id to make it unique\n    id = `${id}_${newCount}`;\n  } else {\n    // If id is unique and wasn't used, add it to usedUids and start count at 0\n    usedUids[id] = 0;\n  }\n  // Return unique id\n  if (refId) {\n    return `${id}_${refId}`;\n  }\n  return id;\n}\n\nfunction lokiMatrixToTimeSeries(matrixResult: LokiMatrixResult, options: TransformerOptions): TimeSeries {\n  const name = createMetricLabel(matrixResult.metric, options);\n  return {\n    target: name,\n    title: name,\n    datapoints: lokiPointsToTimeseriesPoints(matrixResult.values, options),\n    tags: matrixResult.metric,\n    meta: options.meta,\n    refId: options.refId,\n  };\n}\n\nexport function lokiPointsToTimeseriesPoints(\n  data: Array<[number, string]>,\n  options: TransformerOptions\n): TimeSeriesValue[][] {\n  const stepMs = options.step * 1000;\n  const datapoints: TimeSeriesValue[][] = [];\n\n  let baseTimestampMs = options.start / 1e6;\n  for (const [time, value] of data) {\n    let datapointValue: TimeSeriesValue = parseFloat(value);\n\n    if (isNaN(datapointValue)) {\n      datapointValue = null;\n    }\n\n    const timestamp = time * 1000;\n    for (let t = baseTimestampMs; t < timestamp; t += stepMs) {\n      datapoints.push([null, t]);\n    }\n\n    baseTimestampMs = timestamp + stepMs;\n    datapoints.push([datapointValue, timestamp]);\n  }\n\n  const endTimestamp = options.end / 1e6;\n  for (let t = baseTimestampMs; t <= endTimestamp; t += stepMs) {\n    datapoints.push([null, t]);\n  }\n\n  return datapoints;\n}\n\nexport function lokiResultsToTableModel(\n  lokiResults: Array<LokiMatrixResult | LokiVectorResult>,\n  resultCount: number,\n  refId: string,\n  meta: QueryResultMeta,\n  valueWithRefId?: boolean\n): TableModel {\n  if (!lokiResults || lokiResults.length === 0) {\n    return new TableModel();\n  }\n\n  // Collect all labels across all metrics\n  const metricLabels: Set<string> = new Set<string>(\n    lokiResults.reduce((acc, cur) => acc.concat(Object.keys(cur.metric)), [] as string[])\n  );\n\n  // Sort metric labels, create columns for them and record their index\n  const sortedLabels = [...metricLabels.values()].sort();\n  const table = new TableModel();\n  table.refId = refId;\n  table.meta = meta;\n  table.columns = [\n    { text: 'Time', type: FieldType.time },\n    ...sortedLabels.map((label) => ({ text: label, filterable: true, type: FieldType.string })),\n    { text: resultCount > 1 || valueWithRefId ? `Value #${refId}` : 'Value', type: FieldType.number },\n  ];\n\n  // Populate rows, set value to empty string when label not present.\n  lokiResults.forEach((series) => {\n    const newSeries: LokiMatrixResult = {\n      metric: series.metric,\n      values: (series as LokiVectorResult).value\n        ? [(series as LokiVectorResult).value]\n        : (series as LokiMatrixResult).values,\n    };\n\n    if (!newSeries.values) {\n      return;\n    }\n\n    if (!newSeries.metric) {\n      table.rows.concat(newSeries.values.map(([a, b]) => [a * 1000, parseFloat(b)]));\n    } else {\n      table.rows.push(\n        ...newSeries.values.map(([a, b]) => [\n          a * 1000,\n          ...sortedLabels.map((label) => newSeries.metric[label] || ''),\n          parseFloat(b),\n        ])\n      );\n    }\n  });\n\n  return table;\n}\n\nexport function createMetricLabel(labelData: { [key: string]: string }, options?: TransformerOptions) {\n  let label =\n    options === undefined || isEmpty(options.legendFormat)\n      ? getOriginalMetricName(labelData)\n      : renderTemplate(getTemplateSrv().replace(options.legendFormat ?? '', options.scopedVars), labelData);\n\n  if (!label && options) {\n    label = options.query;\n  }\n  return label;\n}\n\nfunction renderTemplate(aliasPattern: string, aliasData: { [key: string]: string }) {\n  const aliasRegex = /\\{\\{\\s*(.+?)\\s*\\}\\}/g;\n  return aliasPattern.replace(aliasRegex, (_, g1) => (aliasData[g1] ? aliasData[g1] : g1));\n}\n\nfunction getOriginalMetricName(labelData: { [key: string]: string }) {\n  const metricName = labelData.__name__ || '';\n  delete labelData.__name__;\n  const labelPart = Object.entries(labelData)\n    .map((label) => `${label[0]}=\"${label[1]}\"`)\n    .join(',');\n  return `${metricName}{${labelPart}}`;\n}\n\nexport function decamelize(s: string): string {\n  return s.replace(/[A-Z]/g, (m) => ` ${m.toLowerCase()}`);\n}\n\n// Turn loki stats { metric: value } into meta stat { title: metric, value: value }\nfunction lokiStatsToMetaStat(stats: LokiStats | undefined): QueryResultMetaStat[] {\n  const result: QueryResultMetaStat[] = [];\n\n  if (!stats) {\n    return result;\n  }\n\n  for (const section in stats) {\n    const values = stats[section];\n    for (const label in values) {\n      const value = values[label];\n      let unit;\n      if (/time/i.test(label) && value) {\n        unit = 's';\n      } else if (/bytes.*persecond/i.test(label)) {\n        unit = 'Bps';\n      } else if (/bytes/i.test(label)) {\n        unit = 'decbytes';\n      }\n      const title = `${capitalize(section)}: ${decamelize(label)}`;\n      result.push({ displayName: title, value, unit });\n    }\n  }\n\n  return result;\n}\n\nexport function lokiStreamsToDataFrames(\n  response: LokiStreamResponse,\n  target: { refId: string; expr?: string },\n  limit: number,\n  config: LokiOptions,\n  reverse = false\n): DataFrame[] {\n  const data = limit > 0 ? response.data.result : [];\n  const stats: QueryResultMetaStat[] = lokiStatsToMetaStat(response.data.stats);\n  // Use custom mechanism to identify which stat we want to promote to label\n  const custom = {\n    lokiQueryStatKey: 'Summary: total bytes processed',\n  };\n\n  const meta: QueryResultMeta = {\n    searchWords: getHighlighterExpressionsFromQuery(formatQuery(target.expr)),\n    limit,\n    stats,\n    custom,\n    preferredVisualisationType: 'logs',\n  };\n\n  const series: DataFrame[] = data.map((stream) => {\n    const dataFrame = lokiStreamResultToDataFrame(stream, reverse, target.refId);\n    enhanceDataFrame(dataFrame, config);\n\n    if (meta.custom && dataFrame.fields.some((f) => f.labels && Object.keys(f.labels).some((l) => l === '__error__'))) {\n      meta.custom.error = 'Error when parsing some of the logs';\n    }\n\n    return {\n      ...dataFrame,\n      refId: target.refId,\n      meta,\n    };\n  });\n\n  if (stats.length && !data.length) {\n    return [\n      {\n        fields: [],\n        length: 0,\n        refId: target.refId,\n        meta,\n      },\n    ];\n  }\n\n  return series;\n}\n\n/**\n * Adds new fields and DataLinks to DataFrame based on DataSource instance config.\n */\nexport const enhanceDataFrame = (dataFrame: DataFrame, config: LokiOptions | null): void => {\n  if (!config) {\n    return;\n  }\n\n  const derivedFields = config.derivedFields ?? [];\n  if (!derivedFields.length) {\n    return;\n  }\n  const derivedFieldsGrouped = groupBy(derivedFields, 'name');\n\n  const newFields = Object.values(derivedFieldsGrouped).map(fieldFromDerivedFieldConfig);\n\n  const view = new DataFrameView(dataFrame);\n  view.forEach((row: { line: string }) => {\n    for (const field of newFields) {\n      const logMatch = row.line.match(derivedFieldsGrouped[field.name][0].matcherRegex);\n      field.values.add(logMatch && logMatch[1]);\n    }\n  });\n\n  dataFrame.fields = [...dataFrame.fields, ...newFields];\n};\n\n/**\n * Transform derivedField config into dataframe field with config that contains link.\n */\nfunction fieldFromDerivedFieldConfig(derivedFieldConfigs: DerivedFieldConfig[]): Field<any, ArrayVector> {\n  const dataSourceSrv = getDataSourceSrv();\n\n  const dataLinks = derivedFieldConfigs.reduce((acc, derivedFieldConfig) => {\n    // Having field.datasourceUid means it is an internal link.\n    if (derivedFieldConfig.datasourceUid) {\n      const dsSettings = dataSourceSrv.getInstanceSettings(derivedFieldConfig.datasourceUid);\n\n      acc.push({\n        // Will be filled out later\n        title: derivedFieldConfig.urlDisplayLabel || '',\n        url: '',\n        // This is hardcoded for Jaeger or Zipkin not way right now to specify datasource specific query object\n        internal: {\n          query: { query: derivedFieldConfig.url },\n          datasourceUid: derivedFieldConfig.datasourceUid,\n          datasourceName: dsSettings?.name ?? 'Data source not found',\n        },\n      });\n    } else if (derivedFieldConfig.url) {\n      acc.push({\n        // We do not know what title to give here so we count on presentation layer to create a title from metadata.\n        title: derivedFieldConfig.urlDisplayLabel || '',\n        // This is hardcoded for Jaeger or Zipkin not way right now to specify datasource specific query object\n        url: derivedFieldConfig.url,\n      });\n    }\n    return acc;\n  }, [] as DataLink[]);\n\n  return {\n    name: derivedFieldConfigs[0].name,\n    type: FieldType.string,\n    config: {\n      links: dataLinks,\n    },\n    // We are adding values later on\n    values: new ArrayVector<string>([]),\n  };\n}\n\nexport function rangeQueryResponseToTimeSeries(\n  response: LokiResponse,\n  query: LokiRangeQueryRequest,\n  target: LokiQuery,\n  responseListLength: number,\n  scopedVars: ScopedVars\n): TimeSeries[] {\n  /** Show results of Loki metric queries only in graph */\n  const meta: QueryResultMeta = {\n    preferredVisualisationType: 'graph',\n  };\n  const transformerOptions: TransformerOptions = {\n    format: target.format,\n    legendFormat: target.legendFormat ?? '',\n    start: query.start!,\n    end: query.end!,\n    step: query.step!,\n    query: query.query,\n    responseListLength,\n    refId: target.refId,\n    meta,\n    valueWithRefId: target.valueWithRefId,\n    scopedVars,\n  };\n\n  switch (response.data.resultType) {\n    case LokiResultType.Vector:\n      return response.data.result.map((vecResult) =>\n        lokiMatrixToTimeSeries({ metric: vecResult.metric, values: [vecResult.value] }, transformerOptions)\n      );\n    case LokiResultType.Matrix:\n      return response.data.result.map((matrixResult) => lokiMatrixToTimeSeries(matrixResult, transformerOptions));\n    default:\n      return [];\n  }\n}\n\nexport function processRangeQueryResponse(\n  response: LokiResponse,\n  target: LokiQuery,\n  query: LokiRangeQueryRequest,\n  responseListLength: number,\n  limit: number,\n  config: LokiOptions,\n  scopedVars: ScopedVars,\n  reverse = false\n) {\n  switch (response.data.resultType) {\n    case LokiResultType.Stream:\n      return of({\n        data: lokiStreamsToDataFrames(response as LokiStreamResponse, target, limit, config, reverse),\n        key: `${target.refId}_log`,\n      });\n\n    case LokiResultType.Vector:\n    case LokiResultType.Matrix:\n      return of({\n        data: rangeQueryResponseToTimeSeries(\n          response,\n          query,\n          {\n            ...target,\n            format: 'time_series',\n          },\n          responseListLength,\n          scopedVars\n        ),\n        key: target.refId,\n      });\n    default:\n      throw new Error(`Unknown result type \"${(response.data as any).resultType}\".`);\n  }\n}\n","import { __assign, __extends } from \"tslib\";\nimport { Subject, AnonymousSubject } from '../../Subject';\nimport { Subscriber } from '../../Subscriber';\nimport { Observable } from '../../Observable';\nimport { Subscription } from '../../Subscription';\nimport { ReplaySubject } from '../../ReplaySubject';\nvar DEFAULT_WEBSOCKET_CONFIG = {\n    url: '',\n    deserializer: function (e) { return JSON.parse(e.data); },\n    serializer: function (value) { return JSON.stringify(value); },\n};\nvar WEBSOCKETSUBJECT_INVALID_ERROR_OBJECT = 'WebSocketSubject.error must be called with an object with an error code, and an optional reason: { code: number, reason: string }';\nvar WebSocketSubject = (function (_super) {\n    __extends(WebSocketSubject, _super);\n    function WebSocketSubject(urlConfigOrSource, destination) {\n        var _this = _super.call(this) || this;\n        _this._socket = null;\n        if (urlConfigOrSource instanceof Observable) {\n            _this.destination = destination;\n            _this.source = urlConfigOrSource;\n        }\n        else {\n            var config = (_this._config = __assign({}, DEFAULT_WEBSOCKET_CONFIG));\n            _this._output = new Subject();\n            if (typeof urlConfigOrSource === 'string') {\n                config.url = urlConfigOrSource;\n            }\n            else {\n                for (var key in urlConfigOrSource) {\n                    if (urlConfigOrSource.hasOwnProperty(key)) {\n                        config[key] = urlConfigOrSource[key];\n                    }\n                }\n            }\n            if (!config.WebSocketCtor && WebSocket) {\n                config.WebSocketCtor = WebSocket;\n            }\n            else if (!config.WebSocketCtor) {\n                throw new Error('no WebSocket constructor can be found');\n            }\n            _this.destination = new ReplaySubject();\n        }\n        return _this;\n    }\n    WebSocketSubject.prototype.lift = function (operator) {\n        var sock = new WebSocketSubject(this._config, this.destination);\n        sock.operator = operator;\n        sock.source = this;\n        return sock;\n    };\n    WebSocketSubject.prototype._resetState = function () {\n        this._socket = null;\n        if (!this.source) {\n            this.destination = new ReplaySubject();\n        }\n        this._output = new Subject();\n    };\n    WebSocketSubject.prototype.multiplex = function (subMsg, unsubMsg, messageFilter) {\n        var self = this;\n        return new Observable(function (observer) {\n            try {\n                self.next(subMsg());\n            }\n            catch (err) {\n                observer.error(err);\n            }\n            var subscription = self.subscribe(function (x) {\n                try {\n                    if (messageFilter(x)) {\n                        observer.next(x);\n                    }\n                }\n                catch (err) {\n                    observer.error(err);\n                }\n            }, function (err) { return observer.error(err); }, function () { return observer.complete(); });\n            return function () {\n                try {\n                    self.next(unsubMsg());\n                }\n                catch (err) {\n                    observer.error(err);\n                }\n                subscription.unsubscribe();\n            };\n        });\n    };\n    WebSocketSubject.prototype._connectSocket = function () {\n        var _this = this;\n        var _a = this._config, WebSocketCtor = _a.WebSocketCtor, protocol = _a.protocol, url = _a.url, binaryType = _a.binaryType;\n        var observer = this._output;\n        var socket = null;\n        try {\n            socket = protocol ? new WebSocketCtor(url, protocol) : new WebSocketCtor(url);\n            this._socket = socket;\n            if (binaryType) {\n                this._socket.binaryType = binaryType;\n            }\n        }\n        catch (e) {\n            observer.error(e);\n            return;\n        }\n        var subscription = new Subscription(function () {\n            _this._socket = null;\n            if (socket && socket.readyState === 1) {\n                socket.close();\n            }\n        });\n        socket.onopen = function (evt) {\n            var _socket = _this._socket;\n            if (!_socket) {\n                socket.close();\n                _this._resetState();\n                return;\n            }\n            var openObserver = _this._config.openObserver;\n            if (openObserver) {\n                openObserver.next(evt);\n            }\n            var queue = _this.destination;\n            _this.destination = Subscriber.create(function (x) {\n                if (socket.readyState === 1) {\n                    try {\n                        var serializer = _this._config.serializer;\n                        socket.send(serializer(x));\n                    }\n                    catch (e) {\n                        _this.destination.error(e);\n                    }\n                }\n            }, function (err) {\n                var closingObserver = _this._config.closingObserver;\n                if (closingObserver) {\n                    closingObserver.next(undefined);\n                }\n                if (err && err.code) {\n                    socket.close(err.code, err.reason);\n                }\n                else {\n                    observer.error(new TypeError(WEBSOCKETSUBJECT_INVALID_ERROR_OBJECT));\n                }\n                _this._resetState();\n            }, function () {\n                var closingObserver = _this._config.closingObserver;\n                if (closingObserver) {\n                    closingObserver.next(undefined);\n                }\n                socket.close();\n                _this._resetState();\n            });\n            if (queue && queue instanceof ReplaySubject) {\n                subscription.add(queue.subscribe(_this.destination));\n            }\n        };\n        socket.onerror = function (e) {\n            _this._resetState();\n            observer.error(e);\n        };\n        socket.onclose = function (e) {\n            _this._resetState();\n            var closeObserver = _this._config.closeObserver;\n            if (closeObserver) {\n                closeObserver.next(e);\n            }\n            if (e.wasClean) {\n                observer.complete();\n            }\n            else {\n                observer.error(e);\n            }\n        };\n        socket.onmessage = function (e) {\n            try {\n                var deserializer = _this._config.deserializer;\n                observer.next(deserializer(e));\n            }\n            catch (err) {\n                observer.error(err);\n            }\n        };\n    };\n    WebSocketSubject.prototype._subscribe = function (subscriber) {\n        var _this = this;\n        var source = this.source;\n        if (source) {\n            return source.subscribe(subscriber);\n        }\n        if (!this._socket) {\n            this._connectSocket();\n        }\n        this._output.subscribe(subscriber);\n        subscriber.add(function () {\n            var _socket = _this._socket;\n            if (_this._output.observers.length === 0) {\n                if (_socket && (_socket.readyState === 1 || _socket.readyState === 0)) {\n                    _socket.close();\n                }\n                _this._resetState();\n            }\n        });\n        return subscriber;\n    };\n    WebSocketSubject.prototype.unsubscribe = function () {\n        var _socket = this._socket;\n        if (_socket && (_socket.readyState === 1 || _socket.readyState === 0)) {\n            _socket.close();\n        }\n        this._resetState();\n        _super.prototype.unsubscribe.call(this);\n    };\n    return WebSocketSubject;\n}(AnonymousSubject));\nexport { WebSocketSubject };\n//# sourceMappingURL=WebSocketSubject.js.map","import { DataFrame, FieldType, parseLabels, KeyValue, CircularDataFrame } from '@grafana/data';\nimport { Observable, throwError, timer } from 'rxjs';\nimport { webSocket } from 'rxjs/webSocket';\nimport { LokiTailResponse } from './types';\nimport { finalize, map, retryWhen, mergeMap } from 'rxjs/operators';\nimport { appendResponseToBufferedData } from './result_transformer';\n\n/**\n * Maps directly to a query in the UI (refId is key)\n */\nexport interface LokiLiveTarget {\n  query: string;\n  url: string;\n  refId: string;\n  size: number;\n}\n\n/**\n * Cache of websocket streams that can be returned as observable. In case there already is a stream for particular\n * target it is returned and on subscription returns the latest dataFrame.\n */\nexport class LiveStreams {\n  private streams: KeyValue<Observable<DataFrame[]>> = {};\n\n  getStream(target: LokiLiveTarget, retryInterval = 5000): Observable<DataFrame[]> {\n    let stream = this.streams[target.url];\n\n    if (stream) {\n      return stream;\n    }\n\n    const data = new CircularDataFrame({ capacity: target.size });\n    data.addField({ name: 'ts', type: FieldType.time, config: { displayName: 'Time' } });\n    data.addField({ name: 'tsNs', type: FieldType.time, config: { displayName: 'Time ns' } });\n    data.addField({ name: 'line', type: FieldType.string }).labels = parseLabels(target.query);\n    data.addField({ name: 'labels', type: FieldType.other }); // The labels for each line\n    data.addField({ name: 'id', type: FieldType.string });\n    data.meta = { ...data.meta, preferredVisualisationType: 'logs' };\n    data.refId = target.refId;\n\n    stream = webSocket<LokiTailResponse>(target.url).pipe(\n      map((response: LokiTailResponse) => {\n        appendResponseToBufferedData(response, data);\n        return [data];\n      }),\n      retryWhen((attempts: Observable<any>) =>\n        attempts.pipe(\n          mergeMap((error, i) => {\n            const retryAttempt = i + 1;\n            // Code 1006 is used to indicate that a connection was closed abnormally.\n            // Added hard limit of 30 on number of retries.\n            // If connection was closed abnormally, and we wish to retry, otherwise throw error.\n            if (error.code === 1006 && retryAttempt < 30) {\n              if (retryAttempt > 10) {\n                // If more than 10 times retried, consol.warn, but keep reconnecting\n                console.warn(\n                  `Websocket connection is being disrupted. We keep reconnecting but consider starting new live tailing again. Error: ${error.reason}`\n                );\n              }\n              // Retry every 5s\n              return timer(retryInterval);\n            }\n            return throwError(error);\n          })\n        )\n      ),\n      finalize(() => {\n        delete this.streams[target.url];\n      })\n    );\n    this.streams[target.url] = stream;\n\n    return stream;\n  }\n}\n","import { WebSocketSubject } from './WebSocketSubject';\nexport function webSocket(urlConfigOrSource) {\n    return new WebSocketSubject(urlConfigOrSource);\n}\n//# sourceMappingURL=webSocket.js.map","// Libraries\nimport { chain, difference } from 'lodash';\nimport LRU from 'lru-cache';\n\n// Services & Utils\nimport {\n  extractLabelMatchers,\n  parseSelector,\n  processLabels,\n  toPromLikeQuery,\n} from 'app/plugins/datasource/prometheus/language_utils';\nimport syntax, { FUNCTIONS, PIPE_PARSERS, PIPE_OPERATORS } from './syntax';\n\n// Types\nimport { LokiQuery } from './types';\nimport { dateTime, AbsoluteTimeRange, LanguageProvider, HistoryItem, AbstractQuery } from '@grafana/data';\n\nimport LokiDatasource from './datasource';\nimport { CompletionItem, TypeaheadInput, TypeaheadOutput, CompletionItemGroup } from '@grafana/ui';\nimport Prism, { Grammar } from 'prismjs';\n\nconst DEFAULT_KEYS = ['job', 'namespace'];\nconst EMPTY_SELECTOR = '{}';\nconst HISTORY_ITEM_COUNT = 10;\nconst HISTORY_COUNT_CUTOFF = 1000 * 60 * 60 * 24; // 24h\nconst NS_IN_MS = 1000000;\n\n// When changing RATE_RANGES, check if Prometheus/PromQL ranges should be changed too\n// @see public/app/plugins/datasource/prometheus/promql.ts\nconst RATE_RANGES: CompletionItem[] = [\n  { label: '$__interval', sortValue: '$__interval' },\n  { label: '$__range', sortValue: '$__range' },\n  { label: '1m', sortValue: '00:01:00' },\n  { label: '5m', sortValue: '00:05:00' },\n  { label: '10m', sortValue: '00:10:00' },\n  { label: '30m', sortValue: '00:30:00' },\n  { label: '1h', sortValue: '01:00:00' },\n  { label: '1d', sortValue: '24:00:00' },\n];\n\nexport const LABEL_REFRESH_INTERVAL = 1000 * 30; // 30sec\n\nconst wrapLabel = (label: string) => ({ label, filterText: `\\\"${label}\\\"` });\n\nexport type LokiHistoryItem = HistoryItem<LokiQuery>;\n\ntype TypeaheadContext = {\n  history?: LokiHistoryItem[];\n  absoluteRange?: AbsoluteTimeRange;\n};\n\nexport function addHistoryMetadata(item: CompletionItem, history: LokiHistoryItem[]): CompletionItem {\n  const cutoffTs = Date.now() - HISTORY_COUNT_CUTOFF;\n  const historyForItem = history.filter((h) => h.ts > cutoffTs && h.query.expr === item.label);\n  let hint = `Queried ${historyForItem.length} times in the last 24h.`;\n  const recent = historyForItem[0];\n\n  if (recent) {\n    const lastQueried = dateTime(recent.ts).fromNow();\n    hint = `${hint} Last queried ${lastQueried}.`;\n  }\n\n  return {\n    ...item,\n    documentation: hint,\n  };\n}\n\nexport default class LokiLanguageProvider extends LanguageProvider {\n  labelKeys: string[];\n  labelFetchTs: number;\n  started = false;\n  datasource: LokiDatasource;\n  lookupsDisabled = false; // Dynamically set to true for big/slow instances\n\n  /**\n   *  Cache for labels of series. This is bit simplistic in the sense that it just counts responses each as a 1 and does\n   *  not account for different size of a response. If that is needed a `length` function can be added in the options.\n   *  10 as a max size is totally arbitrary right now.\n   */\n  private seriesCache = new LRU<string, Record<string, string[]>>(10);\n  private labelsCache = new LRU<string, string[]>(10);\n\n  constructor(datasource: LokiDatasource, initialValues?: any) {\n    super();\n\n    this.datasource = datasource;\n    this.labelKeys = [];\n    this.labelFetchTs = 0;\n\n    Object.assign(this, initialValues);\n  }\n\n  // Strip syntax chars\n  cleanText = (s: string) => s.replace(/[{}[\\]=\"(),!~+\\-*/^%\\|]/g, '').trim();\n\n  getSyntax(): Grammar {\n    return syntax;\n  }\n\n  request = async (url: string, params?: any): Promise<any> => {\n    try {\n      return await this.datasource.metadataRequest(url, params);\n    } catch (error) {\n      console.error(error);\n    }\n\n    return undefined;\n  };\n\n  /**\n   * Initialise the language provider by fetching set of labels. Without this initialisation the provider would return\n   * just a set of hardcoded default labels on provideCompletionItems or a recent queries from history.\n   */\n  start = () => {\n    if (!this.startTask) {\n      this.startTask = this.fetchLabels().then(() => {\n        this.started = true;\n        return [];\n      });\n    }\n\n    return this.startTask;\n  };\n\n  getLabelKeys(): string[] {\n    return this.labelKeys;\n  }\n\n  /**\n   * Return suggestions based on input that can be then plugged into a typeahead dropdown.\n   * Keep this DOM-free for testing\n   * @param input\n   * @param context Is optional in types but is required in case we are doing getLabelCompletionItems\n   * @param context.absoluteRange Required in case we are doing getLabelCompletionItems\n   * @param context.history Optional used only in getEmptyCompletionItems\n   */\n  async provideCompletionItems(input: TypeaheadInput, context?: TypeaheadContext): Promise<TypeaheadOutput> {\n    const { wrapperClasses, value, prefix, text } = input;\n    const emptyResult: TypeaheadOutput = { suggestions: [] };\n\n    if (!value) {\n      return emptyResult;\n    }\n\n    // Local text properties\n    const empty = value?.document.text.length === 0;\n    const selectedLines = value.document.getTextsAtRange(value.selection);\n    const currentLine = selectedLines.size === 1 ? selectedLines.first().getText() : null;\n\n    const nextCharacter = currentLine ? currentLine[value.selection.anchor.offset] : null;\n\n    // Syntax spans have 3 classes by default. More indicate a recognized token\n    const tokenRecognized = wrapperClasses.length > 3;\n\n    // Non-empty prefix, but not inside known token\n    const prefixUnrecognized = prefix && !tokenRecognized;\n\n    // Prevent suggestions in `function(|suffix)`\n    const noSuffix = !nextCharacter || nextCharacter === ')';\n\n    // Prefix is safe if it does not immediately follow a complete expression and has no text after it\n    const safePrefix = prefix && !text.match(/^['\"~=\\]})\\s]+$/) && noSuffix;\n\n    // About to type next operand if preceded by binary operator\n    const operatorsPattern = /[+\\-*/^%]/;\n    const isNextOperand = text.match(operatorsPattern);\n\n    // Determine candidates by CSS context\n    if (wrapperClasses.includes('context-range')) {\n      // Suggestions for metric[|]\n      return this.getRangeCompletionItems();\n    } else if (wrapperClasses.includes('context-labels')) {\n      // Suggestions for {|} and {foo=|}\n      return await this.getLabelCompletionItems(input);\n    } else if (wrapperClasses.includes('context-pipe')) {\n      return this.getPipeCompletionItem();\n    } else if (empty) {\n      // Suggestions for empty query field\n      return this.getEmptyCompletionItems(context);\n    } else if (prefixUnrecognized && noSuffix && !isNextOperand) {\n      // Show term suggestions in a couple of scenarios\n      return this.getBeginningCompletionItems(context);\n    } else if (prefixUnrecognized && safePrefix) {\n      // Show term suggestions in a couple of scenarios\n      return this.getTermCompletionItems();\n    }\n\n    return emptyResult;\n  }\n\n  getBeginningCompletionItems = (context?: TypeaheadContext): TypeaheadOutput => {\n    return {\n      suggestions: [...this.getEmptyCompletionItems(context).suggestions, ...this.getTermCompletionItems().suggestions],\n    };\n  };\n\n  getEmptyCompletionItems(context?: TypeaheadContext): TypeaheadOutput {\n    const history = context?.history;\n    const suggestions = [];\n\n    if (history?.length) {\n      const historyItems = chain(history)\n        .map((h) => h.query.expr)\n        .filter()\n        .uniq()\n        .take(HISTORY_ITEM_COUNT)\n        .map(wrapLabel)\n        .map((item) => addHistoryMetadata(item, history))\n        .value();\n\n      suggestions.push({\n        prefixMatch: true,\n        skipSort: true,\n        label: 'History',\n        items: historyItems,\n      });\n    }\n\n    return { suggestions };\n  }\n\n  getTermCompletionItems = (): TypeaheadOutput => {\n    const suggestions = [];\n\n    suggestions.push({\n      prefixMatch: true,\n      label: 'Functions',\n      items: FUNCTIONS.map((suggestion) => ({ ...suggestion, kind: 'function' })),\n    });\n\n    return { suggestions };\n  };\n\n  getPipeCompletionItem = (): TypeaheadOutput => {\n    const suggestions = [];\n\n    suggestions.push({\n      label: 'Operators',\n      items: PIPE_OPERATORS.map((suggestion) => ({ ...suggestion, kind: 'operators' })),\n    });\n\n    suggestions.push({\n      label: 'Parsers',\n      items: PIPE_PARSERS.map((suggestion) => ({ ...suggestion, kind: 'parsers' })),\n    });\n\n    return { suggestions };\n  };\n\n  getRangeCompletionItems(): TypeaheadOutput {\n    return {\n      context: 'context-range',\n      suggestions: [\n        {\n          label: 'Range vector',\n          items: [...RATE_RANGES],\n        },\n      ],\n    };\n  }\n\n  async getLabelCompletionItems({ text, wrapperClasses, labelKey, value }: TypeaheadInput): Promise<TypeaheadOutput> {\n    let context = 'context-labels';\n    const suggestions: CompletionItemGroup[] = [];\n    if (!value) {\n      return { context, suggestions: [] };\n    }\n    const line = value.anchorBlock.getText();\n    const cursorOffset = value.selection.anchor.offset;\n    const isValueStart = text.match(/^(=|=~|!=|!~)/);\n\n    // Get normalized selector\n    let selector;\n    let parsedSelector;\n    try {\n      parsedSelector = parseSelector(line, cursorOffset);\n      selector = parsedSelector.selector;\n    } catch {\n      selector = EMPTY_SELECTOR;\n    }\n\n    if (!labelKey && selector === EMPTY_SELECTOR) {\n      // start task gets all labels\n      await this.start();\n      const allLabels = this.getLabelKeys();\n      return { context, suggestions: [{ label: `Labels`, items: allLabels.map(wrapLabel) }] };\n    }\n\n    const existingKeys = parsedSelector ? parsedSelector.labelKeys : [];\n\n    let labelValues;\n    // Query labels for selector\n    if (selector) {\n      if (selector === EMPTY_SELECTOR && labelKey) {\n        const labelValuesForKey = await this.getLabelValues(labelKey);\n        labelValues = { [labelKey]: labelValuesForKey };\n      } else {\n        labelValues = await this.getSeriesLabels(selector);\n      }\n    }\n\n    if (!labelValues) {\n      console.warn(`Server did not return any values for selector = ${selector}`);\n      return { context, suggestions };\n    }\n\n    if ((text && isValueStart) || wrapperClasses.includes('attr-value')) {\n      // Label values\n      if (labelKey && labelValues[labelKey]) {\n        context = 'context-label-values';\n        suggestions.push({\n          label: `Label values for \"${labelKey}\"`,\n          // Filter to prevent previously selected values from being repeatedly suggested\n          items: labelValues[labelKey].map(wrapLabel).filter(({ filterText }) => filterText !== text),\n        });\n      }\n    } else {\n      // Label keys\n      const labelKeys = labelValues ? Object.keys(labelValues) : DEFAULT_KEYS;\n      if (labelKeys) {\n        const possibleKeys = difference(labelKeys, existingKeys);\n        if (possibleKeys.length) {\n          const newItems = possibleKeys.map((key) => ({ label: key }));\n          const newSuggestion: CompletionItemGroup = { label: `Labels`, items: newItems };\n          suggestions.push(newSuggestion);\n        }\n      }\n    }\n\n    return { context, suggestions };\n  }\n\n  importFromAbstractQuery(labelBasedQuery: AbstractQuery): LokiQuery {\n    return toPromLikeQuery(labelBasedQuery);\n  }\n\n  exportToAbstractQuery(query: LokiQuery): AbstractQuery {\n    const lokiQuery = query.expr;\n    if (!lokiQuery || lokiQuery.length === 0) {\n      return { refId: query.refId, labelMatchers: [] };\n    }\n    const tokens = Prism.tokenize(lokiQuery, syntax);\n    return {\n      refId: query.refId,\n      labelMatchers: extractLabelMatchers(tokens),\n    };\n  }\n\n  async getSeriesLabels(selector: string) {\n    if (this.lookupsDisabled) {\n      return undefined;\n    }\n    try {\n      return await this.fetchSeriesLabels(selector);\n    } catch (error) {\n      // TODO: better error handling\n      console.error(error);\n      return undefined;\n    }\n  }\n\n  /**\n   * Fetches all label keys\n   */\n  async fetchLabels(): Promise<string[]> {\n    const url = '/loki/api/v1/label';\n    const timeRange = this.datasource.getTimeRangeParams();\n    this.labelFetchTs = Date.now().valueOf();\n\n    const res = await this.request(url, timeRange);\n    if (Array.isArray(res)) {\n      const labels = res\n        .slice()\n        .sort()\n        .filter((label) => label !== '__name__');\n      this.labelKeys = labels;\n    }\n\n    return [];\n  }\n\n  async refreshLogLabels(forceRefresh?: boolean) {\n    if ((this.labelKeys && Date.now().valueOf() - this.labelFetchTs > LABEL_REFRESH_INTERVAL) || forceRefresh) {\n      await this.fetchLabels();\n    }\n  }\n\n  /**\n   * Fetch labels for a selector. This is cached by it's args but also by the global timeRange currently selected as\n   * they can change over requested time.\n   * @param name\n   */\n  fetchSeriesLabels = async (match: string): Promise<Record<string, string[]>> => {\n    const url = '/loki/api/v1/series';\n    const { start, end } = this.datasource.getTimeRangeParams();\n\n    const cacheKey = this.generateCacheKey(url, start, end, match);\n    let value = this.seriesCache.get(cacheKey);\n    if (!value) {\n      // Clear value when requesting new one. Empty object being truthy also makes sure we don't request twice.\n      this.seriesCache.set(cacheKey, {});\n      const params = { 'match[]': match, start, end };\n      const data = await this.request(url, params);\n      const { values } = processLabels(data);\n      value = values;\n      this.seriesCache.set(cacheKey, value);\n    }\n    return value;\n  };\n\n  /**\n   * Fetch series for a selector. Use this for raw results. Use fetchSeriesLabels() to get labels.\n   * @param match\n   */\n  fetchSeries = async (match: string): Promise<Array<Record<string, string>>> => {\n    const url = '/loki/api/v1/series';\n    const { start, end } = this.datasource.getTimeRangeParams();\n    const params = { 'match[]': match, start, end };\n    return await this.request(url, params);\n  };\n\n  // Cache key is a bit different here. We round up to a minute the intervals.\n  // The rounding may seem strange but makes relative intervals like now-1h less prone to need separate request every\n  // millisecond while still actually getting all the keys for the correct interval. This still can create problems\n  // when user does not the newest values for a minute if already cached.\n  generateCacheKey(url: string, start: number, end: number, param: string): string {\n    return [url, this.roundTime(start), this.roundTime(end), param].join();\n  }\n\n  // Round nanos epoch to nearest 5 minute interval\n  roundTime(nanos: number): number {\n    return nanos ? Math.floor(nanos / NS_IN_MS / 1000 / 60 / 5) : 0;\n  }\n\n  async getLabelValues(key: string): Promise<string[]> {\n    return await this.fetchLabelValues(key);\n  }\n\n  async fetchLabelValues(key: string): Promise<string[]> {\n    const url = `/loki/api/v1/label/${key}/values`;\n    const rangeParams = this.datasource.getTimeRangeParams();\n    const { start, end } = rangeParams;\n\n    const cacheKey = this.generateCacheKey(url, start, end, key);\n    const params = { start, end };\n\n    let labelValues = this.labelsCache.get(cacheKey);\n    if (!labelValues) {\n      // Clear value when requesting new one. Empty object being truthy also makes sure we don't request twice.\n      this.labelsCache.set(cacheKey, []);\n      const res = await this.request(url, params);\n      if (Array.isArray(res)) {\n        labelValues = res.slice().sort();\n        this.labelsCache.set(cacheKey, labelValues);\n      }\n    }\n\n    return labelValues ?? [];\n  }\n}\n","// Libraries\nimport { cloneDeep, isEmpty, map as lodashMap } from 'lodash';\nimport { lastValueFrom, merge, Observable, of, throwError } from 'rxjs';\nimport { catchError, map, switchMap } from 'rxjs/operators';\nimport Prism from 'prismjs';\n\n// Types\nimport {\n  AnnotationEvent,\n  AnnotationQueryRequest,\n  DataFrame,\n  DataFrameView,\n  DataQueryError,\n  DataQueryRequest,\n  DataQueryResponse,\n  DataSourceApi,\n  DataSourceInstanceSettings,\n  DataSourceWithLogsContextSupport,\n  DataSourceWithLogsVolumeSupport,\n  DataSourceWithQueryExportSupport,\n  DataSourceWithQueryImportSupport,\n  dateMath,\n  DateTime,\n  FieldCache,\n  AbstractQuery,\n  FieldType,\n  getLogLevelFromKey,\n  Labels,\n  LoadingState,\n  LogLevel,\n  LogRowModel,\n  QueryResultMeta,\n  ScopedVars,\n  TimeRange,\n} from '@grafana/data';\nimport { BackendSrvRequest, FetchError, getBackendSrv } from '@grafana/runtime';\nimport { getTemplateSrv, TemplateSrv } from 'app/features/templating/template_srv';\nimport { addLabelToQuery } from './add_label_to_query';\nimport { getTimeSrv, TimeSrv } from 'app/features/dashboard/services/TimeSrv';\nimport { convertToWebSocketUrl } from 'app/core/utils/explore';\nimport {\n  lokiResultsToTableModel,\n  lokiStreamResultToDataFrame,\n  lokiStreamsToDataFrames,\n  processRangeQueryResponse,\n} from './result_transformer';\nimport { addParsedLabelToQuery, queryHasPipeParser } from './query_utils';\n\nimport {\n  LokiOptions,\n  LokiQuery,\n  LokiRangeQueryRequest,\n  LokiResultType,\n  LokiStreamResponse,\n  LokiStreamResult,\n} from './types';\nimport { LiveStreams, LokiLiveTarget } from './live_streams';\nimport LanguageProvider from './language_provider';\nimport { serializeParams } from '../../../core/utils/fetch';\nimport { RowContextOptions } from '@grafana/ui/src/components/Logs/LogRowContextProvider';\nimport syntax from './syntax';\nimport { DEFAULT_RESOLUTION } from './components/LokiOptionFields';\nimport { queryLogsVolume } from 'app/core/logs_model';\nimport config from 'app/core/config';\n\nexport type RangeQueryOptions = DataQueryRequest<LokiQuery> | AnnotationQueryRequest<LokiQuery>;\nexport const DEFAULT_MAX_LINES = 1000;\nexport const LOKI_ENDPOINT = '/loki/api/v1';\nconst NS_IN_MS = 1000000;\n\n/**\n * Loki's logs volume query may be expensive as it requires counting all logs in the selected range. If such query\n * takes too much time it may need be made more specific to limit number of logs processed under the hood.\n */\nconst LOGS_VOLUME_TIMEOUT = 10000;\n\nconst RANGE_QUERY_ENDPOINT = `${LOKI_ENDPOINT}/query_range`;\nconst INSTANT_QUERY_ENDPOINT = `${LOKI_ENDPOINT}/query`;\n\nconst DEFAULT_QUERY_PARAMS: Partial<LokiRangeQueryRequest> = {\n  direction: 'BACKWARD',\n  limit: DEFAULT_MAX_LINES,\n  query: '',\n};\n\nexport class LokiDatasource\n  extends DataSourceApi<LokiQuery, LokiOptions>\n  implements\n    DataSourceWithLogsContextSupport,\n    DataSourceWithLogsVolumeSupport<LokiQuery>,\n    DataSourceWithQueryImportSupport<LokiQuery>,\n    DataSourceWithQueryExportSupport<LokiQuery> {\n  private streams = new LiveStreams();\n  languageProvider: LanguageProvider;\n  maxLines: number;\n\n  constructor(\n    private instanceSettings: DataSourceInstanceSettings<LokiOptions>,\n    private readonly templateSrv: TemplateSrv = getTemplateSrv(),\n    private readonly timeSrv: TimeSrv = getTimeSrv()\n  ) {\n    super(instanceSettings);\n\n    this.languageProvider = new LanguageProvider(this);\n    const settingsData = instanceSettings.jsonData || {};\n    this.maxLines = parseInt(settingsData.maxLines ?? '0', 10) || DEFAULT_MAX_LINES;\n  }\n\n  _request(apiUrl: string, data?: any, options?: Partial<BackendSrvRequest>): Observable<Record<string, any>> {\n    const baseUrl = this.instanceSettings.url;\n    const params = data ? serializeParams(data) : '';\n    const url = `${baseUrl}${apiUrl}${params.length ? `?${params}` : ''}`;\n    if (this.instanceSettings.withCredentials || this.instanceSettings.basicAuth) {\n      options = { ...options, withCredentials: true };\n      if (this.instanceSettings.basicAuth) {\n        options.headers = { ...options.headers, Authorization: this.instanceSettings.basicAuth };\n      }\n    }\n    const req = {\n      ...options,\n      url,\n    };\n\n    return getBackendSrv().fetch<Record<string, any>>(req);\n  }\n\n  getLogsVolumeDataProvider(request: DataQueryRequest<LokiQuery>): Observable<DataQueryResponse> | undefined {\n    if (!config.featureToggles.fullRangeLogsVolume) {\n      return undefined;\n    }\n\n    const isLogsVolumeAvailable = request.targets.some((target) => target.expr && !isMetricsQuery(target.expr));\n    if (!isLogsVolumeAvailable) {\n      return undefined;\n    }\n\n    const logsVolumeRequest = cloneDeep(request);\n    logsVolumeRequest.targets = logsVolumeRequest.targets\n      .filter((target) => target.expr && !isMetricsQuery(target.expr))\n      .map((target) => {\n        return {\n          ...target,\n          instant: false,\n          volumeQuery: true,\n          expr: `sum by (level) (count_over_time(${target.expr}[$__interval]))`,\n        };\n      });\n\n    return queryLogsVolume(this, logsVolumeRequest, {\n      timeout: LOGS_VOLUME_TIMEOUT,\n      extractLevel,\n      range: request.range,\n      targets: request.targets,\n    });\n  }\n\n  query(options: DataQueryRequest<LokiQuery>): Observable<DataQueryResponse> {\n    const subQueries: Array<Observable<DataQueryResponse>> = [];\n    const scopedVars = {\n      ...options.scopedVars,\n      ...this.getRangeScopedVars(options.range),\n    };\n    const filteredTargets = options.targets\n      .filter((target) => target.expr && !target.hide)\n      .map((target) => {\n        const expr = this.addAdHocFilters(target.expr);\n        return {\n          ...target,\n          expr: this.templateSrv.replace(expr, scopedVars, this.interpolateQueryExpr),\n        };\n      });\n\n    for (const target of filteredTargets) {\n      if (target.instant) {\n        subQueries.push(this.runInstantQuery(target, options, filteredTargets.length));\n      } else {\n        subQueries.push(this.runRangeQuery(target, options, filteredTargets.length));\n      }\n    }\n\n    // No valid targets, return the empty result to save a round trip.\n    if (isEmpty(subQueries)) {\n      return of({\n        data: [],\n        state: LoadingState.Done,\n      });\n    }\n\n    return merge(...subQueries);\n  }\n\n  runInstantQuery = (\n    target: LokiQuery,\n    options: DataQueryRequest<LokiQuery>,\n    responseListLength = 1\n  ): Observable<DataQueryResponse> => {\n    const timeNs = this.getTime(options.range.to, true);\n    const queryLimit = isMetricsQuery(target.expr) ? options.maxDataPoints : target.maxLines;\n    const query = {\n      query: target.expr,\n      time: `${timeNs + (1e9 - (timeNs % 1e9))}`,\n      limit: Math.min(queryLimit || Infinity, this.maxLines),\n    };\n\n    /** Used only for results of metrics instant queries */\n    const meta: QueryResultMeta = {\n      preferredVisualisationType: 'table',\n    };\n\n    return this._request(INSTANT_QUERY_ENDPOINT, query).pipe(\n      map((response) => {\n        if (response.data.data.resultType === LokiResultType.Stream) {\n          return {\n            data: response.data\n              ? lokiStreamsToDataFrames(\n                  response.data as LokiStreamResponse,\n                  target,\n                  query.limit,\n                  this.instanceSettings.jsonData\n                )\n              : [],\n            key: `${target.refId}_instant`,\n          };\n        }\n\n        return {\n          data: [lokiResultsToTableModel(response.data.data.result, responseListLength, target.refId, meta, true)],\n          key: `${target.refId}_instant`,\n        };\n      }),\n      catchError((err) => throwError(() => this.processError(err, target)))\n    );\n  };\n\n  createRangeQuery(target: LokiQuery, options: RangeQueryOptions, limit: number): LokiRangeQueryRequest {\n    const query = target.expr;\n    let range: { start?: number; end?: number; step?: number } = {};\n    if (options.range) {\n      const startNs = this.getTime(options.range.from, false);\n      const endNs = this.getTime(options.range.to, true);\n      const rangeMs = Math.ceil((endNs - startNs) / 1e6);\n\n      const resolution = target.resolution || (DEFAULT_RESOLUTION.value as number);\n\n      const adjustedInterval =\n        this.adjustInterval((options as DataQueryRequest<LokiQuery>).intervalMs || 1000, resolution, rangeMs) / 1000;\n      // We want to ceil to 3 decimal places\n      const step = Math.ceil(adjustedInterval * 1000) / 1000;\n\n      range = {\n        start: startNs,\n        end: endNs,\n        step,\n      };\n    }\n\n    return {\n      ...DEFAULT_QUERY_PARAMS,\n      ...range,\n      query,\n      limit,\n    };\n  }\n\n  /**\n   * Attempts to send a query to /loki/api/v1/query_range\n   */\n  runRangeQuery = (\n    target: LokiQuery,\n    options: RangeQueryOptions,\n    responseListLength = 1\n  ): Observable<DataQueryResponse> => {\n    // For metric query we use maxDataPoints from the request options which should be something like width of the\n    // visualisation in pixels. In case of logs request we either use lines limit defined in the query target or\n    // global limit defined for the data source which ever is lower.\n    let maxDataPoints = isMetricsQuery(target.expr)\n      ? // We fallback to maxLines here because maxDataPoints is defined as possibly undefined. Not sure that can\n        // actually happen both Dashboards and Explore should send some value here. If not maxLines does not make that\n        // much sense but nor any other arbitrary value.\n        (options as DataQueryRequest<LokiQuery>).maxDataPoints || this.maxLines\n      : // If user wants maxLines 0 we still fallback to data source limit. I think that makes sense as why would anyone\n        // want to do a query and not see any results?\n        target.maxLines || this.maxLines;\n\n    if ((options as DataQueryRequest<LokiQuery>).liveStreaming) {\n      return this.runLiveQuery(target, maxDataPoints);\n    }\n    const query = this.createRangeQuery(target, options, maxDataPoints);\n\n    const headers = target.volumeQuery ? { 'X-Query-Tags': 'Source=logvolhist' } : undefined;\n\n    return this._request(RANGE_QUERY_ENDPOINT, query, { headers }).pipe(\n      catchError((err) => throwError(() => this.processError(err, target))),\n      switchMap((response) =>\n        processRangeQueryResponse(\n          response.data,\n          target,\n          query,\n          responseListLength,\n          maxDataPoints,\n          this.instanceSettings.jsonData,\n          (options as DataQueryRequest<LokiQuery>).scopedVars,\n          (options as DataQueryRequest<LokiQuery>).reverse\n        )\n      )\n    );\n  };\n\n  createLiveTarget(target: LokiQuery, maxDataPoints: number): LokiLiveTarget {\n    const query = target.expr;\n    const baseUrl = this.instanceSettings.url;\n    const params = serializeParams({ query });\n\n    return {\n      query,\n      url: convertToWebSocketUrl(`${baseUrl}/loki/api/v1/tail?${params}`),\n      refId: target.refId,\n      size: maxDataPoints,\n    };\n  }\n\n  /**\n   * Runs live queries which in this case means creating a websocket and listening on it for new logs.\n   * This returns a bit different dataFrame than runQueries as it returns single dataframe even if there are multiple\n   * Loki streams, sets only common labels on dataframe.labels and has additional dataframe.fields.labels for unique\n   * labels per row.\n   */\n  runLiveQuery = (target: LokiQuery, maxDataPoints: number): Observable<DataQueryResponse> => {\n    const liveTarget = this.createLiveTarget(target, maxDataPoints);\n\n    return this.streams.getStream(liveTarget).pipe(\n      map((data) => ({\n        data: data || [],\n        key: `loki-${liveTarget.refId}`,\n        state: LoadingState.Streaming,\n      })),\n      catchError((err: any) => {\n        return throwError(() => `Live tailing was stopped due to following error: ${err.reason}`);\n      })\n    );\n  };\n\n  getRangeScopedVars(range: TimeRange = this.timeSrv.timeRange()) {\n    const msRange = range.to.diff(range.from);\n    const sRange = Math.round(msRange / 1000);\n    return {\n      __range_ms: { text: msRange, value: msRange },\n      __range_s: { text: sRange, value: sRange },\n      __range: { text: sRange + 's', value: sRange + 's' },\n    };\n  }\n\n  interpolateVariablesInQueries(queries: LokiQuery[], scopedVars: ScopedVars): LokiQuery[] {\n    let expandedQueries = queries;\n    if (queries && queries.length) {\n      expandedQueries = queries.map((query) => ({\n        ...query,\n        datasource: this.getRef(),\n        expr: this.templateSrv.replace(query.expr, scopedVars, this.interpolateQueryExpr),\n      }));\n    }\n\n    return expandedQueries;\n  }\n\n  getQueryDisplayText(query: LokiQuery) {\n    return query.expr;\n  }\n\n  getTimeRangeParams() {\n    const timeRange = this.timeSrv.timeRange();\n    return { start: timeRange.from.valueOf() * NS_IN_MS, end: timeRange.to.valueOf() * NS_IN_MS };\n  }\n\n  async importFromAbstractQueries(abstractQueries: AbstractQuery[]): Promise<LokiQuery[]> {\n    await this.languageProvider.start();\n    const existingKeys = this.languageProvider.labelKeys;\n\n    if (existingKeys && existingKeys.length) {\n      abstractQueries = abstractQueries.map((abstractQuery) => {\n        abstractQuery.labelMatchers = abstractQuery.labelMatchers.filter((labelMatcher) => {\n          return existingKeys.includes(labelMatcher.name);\n        });\n        return abstractQuery;\n      });\n    }\n\n    return abstractQueries.map((abstractQuery) => this.languageProvider.importFromAbstractQuery(abstractQuery));\n  }\n\n  async exportToAbstractQueries(queries: LokiQuery[]): Promise<AbstractQuery[]> {\n    return queries.map((query) => this.languageProvider.exportToAbstractQuery(query));\n  }\n\n  async metadataRequest(url: string, params?: Record<string, string | number>) {\n    const res = await lastValueFrom(this._request(url, params, { hideFromInspector: true }));\n    return res.data.data || res.data.values || [];\n  }\n\n  async metricFindQuery(query: string) {\n    if (!query) {\n      return Promise.resolve([]);\n    }\n\n    const interpolated = this.templateSrv.replace(query, {}, this.interpolateQueryExpr);\n    return await this.processMetricFindQuery(interpolated);\n  }\n\n  async processMetricFindQuery(query: string) {\n    const labelNamesRegex = /^label_names\\(\\)\\s*$/;\n    const labelValuesRegex = /^label_values\\((?:(.+),\\s*)?([a-zA-Z_][a-zA-Z0-9_]*)\\)\\s*$/;\n\n    const labelNames = query.match(labelNamesRegex);\n    if (labelNames) {\n      return await this.labelNamesQuery();\n    }\n\n    const labelValues = query.match(labelValuesRegex);\n    if (labelValues) {\n      // If we have query expr, use /series endpoint\n      if (labelValues[1]) {\n        return await this.labelValuesSeriesQuery(labelValues[1], labelValues[2]);\n      }\n      return await this.labelValuesQuery(labelValues[2]);\n    }\n\n    return Promise.resolve([]);\n  }\n\n  async labelNamesQuery() {\n    const url = `${LOKI_ENDPOINT}/label`;\n    const params = this.getTimeRangeParams();\n    const result = await this.metadataRequest(url, params);\n    return result.map((value: string) => ({ text: value }));\n  }\n\n  async labelValuesQuery(label: string) {\n    const params = this.getTimeRangeParams();\n    const url = `${LOKI_ENDPOINT}/label/${label}/values`;\n    const result = await this.metadataRequest(url, params);\n    return result.map((value: string) => ({ text: value }));\n  }\n\n  async labelValuesSeriesQuery(expr: string, label: string) {\n    const timeParams = this.getTimeRangeParams();\n    const params = {\n      ...timeParams,\n      'match[]': expr,\n    };\n    const url = `${LOKI_ENDPOINT}/series`;\n    const streams = new Set();\n    const result = await this.metadataRequest(url, params);\n    result.forEach((stream: { [key: string]: string }) => {\n      if (stream[label]) {\n        streams.add({ text: stream[label] });\n      }\n    });\n\n    return Array.from(streams);\n  }\n\n  // By implementing getTagKeys and getTagValues we add ad-hoc filtters functionality\n  async getTagKeys() {\n    return await this.labelNamesQuery();\n  }\n\n  async getTagValues(options: any = {}) {\n    return await this.labelValuesQuery(options.key);\n  }\n\n  interpolateQueryExpr(value: any, variable: any) {\n    // if no multi or include all do not regexEscape\n    if (!variable.multi && !variable.includeAll) {\n      return lokiRegularEscape(value);\n    }\n\n    if (typeof value === 'string') {\n      return lokiSpecialRegexEscape(value);\n    }\n\n    const escapedValues = lodashMap(value, lokiSpecialRegexEscape);\n    return escapedValues.join('|');\n  }\n\n  modifyQuery(query: LokiQuery, action: any): LokiQuery {\n    let expression = query.expr ?? '';\n    switch (action.type) {\n      case 'ADD_FILTER': {\n        expression = this.addLabelToQuery(expression, action.key, action.value, '=');\n        break;\n      }\n      case 'ADD_FILTER_OUT': {\n        expression = this.addLabelToQuery(expression, action.key, action.value, '!=');\n        break;\n      }\n      default:\n        break;\n    }\n    return { ...query, expr: expression };\n  }\n\n  getTime(date: string | DateTime, roundUp: boolean) {\n    if (typeof date === 'string') {\n      date = dateMath.parse(date, roundUp)!;\n    }\n\n    return Math.ceil(date.valueOf() * 1e6);\n  }\n\n  getLogRowContext = (row: LogRowModel, options?: RowContextOptions): Promise<{ data: DataFrame[] }> => {\n    const target = this.prepareLogRowContextQueryTarget(\n      row,\n      (options && options.limit) || 10,\n      (options && options.direction) || 'BACKWARD'\n    );\n\n    const reverse = options && options.direction === 'FORWARD';\n    return lastValueFrom(\n      this._request(RANGE_QUERY_ENDPOINT, target).pipe(\n        catchError((err) => {\n          const error: DataQueryError = {\n            message: 'Error during context query. Please check JS console logs.',\n            status: err.status,\n            statusText: err.statusText,\n          };\n          throw error;\n        }),\n        switchMap((res) =>\n          of({\n            data: res.data\n              ? res.data.data.result.map((stream: LokiStreamResult) => lokiStreamResultToDataFrame(stream, reverse))\n              : [],\n          })\n        )\n      )\n    );\n  };\n\n  prepareLogRowContextQueryTarget = (row: LogRowModel, limit: number, direction: 'BACKWARD' | 'FORWARD') => {\n    const labels = this.languageProvider.getLabelKeys();\n    const query = Object.keys(row.labels)\n      .map((label: string) => {\n        if (labels.includes(label)) {\n          // escape backslashes in label as users can't escape them by themselves\n          return `${label}=\"${row.labels[label].replace(/\\\\/g, '\\\\\\\\')}\"`;\n        }\n        return '';\n      })\n      // Filter empty strings\n      .filter((label) => !!label)\n      .join(',');\n\n    const contextTimeBuffer = 2 * 60 * 60 * 1000; // 2h buffer\n    const commonTargetOptions = {\n      limit,\n      query: `{${query}}`,\n      expr: `{${query}}`,\n      direction,\n    };\n\n    const fieldCache = new FieldCache(row.dataFrame);\n    const nsField = fieldCache.getFieldByName('tsNs')!;\n    const nsTimestamp = nsField.values.get(row.rowIndex);\n\n    if (direction === 'BACKWARD') {\n      return {\n        ...commonTargetOptions,\n        // convert to ns, we loose some precision here but it is not that important at the far points of the context\n        start: row.timeEpochMs - contextTimeBuffer + '000000',\n        end: nsTimestamp,\n        direction,\n      };\n    } else {\n      return {\n        ...commonTargetOptions,\n        // start param in Loki API is inclusive so we'll have to filter out the row that this request is based from\n        // and any other that were logged in the same ns but before the row. Right now these rows will be lost\n        // because the are before but came it he response that should return only rows after.\n        start: nsTimestamp,\n        // convert to ns, we loose some precision here but it is not that important at the far points of the context\n        end: row.timeEpochMs + contextTimeBuffer + '000000',\n      };\n    }\n  };\n\n  testDatasource() {\n    // Consider only last 10 minutes otherwise request takes too long\n    const startMs = Date.now() - 10 * 60 * 1000;\n    const start = `${startMs}000000`; // API expects nanoseconds\n    return lastValueFrom(\n      this._request(`${LOKI_ENDPOINT}/label`, { start }).pipe(\n        map((res) => {\n          const values: any[] = res?.data?.data || res?.data?.values || [];\n          const testResult =\n            values.length > 0\n              ? { status: 'success', message: 'Data source connected and labels found.' }\n              : {\n                  status: 'error',\n                  message:\n                    'Data source connected, but no labels received. Verify that Loki and Promtail is configured properly.',\n                };\n          return testResult;\n        }),\n        catchError((err: any) => {\n          let message = 'Loki: ';\n          if (err.statusText) {\n            message += err.statusText;\n          } else {\n            message += 'Cannot connect to Loki';\n          }\n\n          if (err.status) {\n            message += `. ${err.status}`;\n          }\n\n          if (err.data && err.data.message) {\n            message += `. ${err.data.message}`;\n          } else if (err.data) {\n            message += `. ${err.data}`;\n          }\n          return of({ status: 'error', message: message });\n        })\n      )\n    );\n  }\n\n  async annotationQuery(options: any): Promise<AnnotationEvent[]> {\n    const {\n      expr,\n      maxLines,\n      instant,\n      stepInterval,\n      tagKeys = '',\n      titleFormat = '',\n      textFormat = '',\n    } = options.annotation;\n\n    if (!expr) {\n      return [];\n    }\n\n    const interpolatedExpr = this.templateSrv.replace(expr, {}, this.interpolateQueryExpr);\n    const query = {\n      refId: `annotation-${options.annotation.name}`,\n      expr: interpolatedExpr,\n      maxLines,\n      instant,\n      stepInterval,\n    };\n    const { data } = instant\n      ? await lastValueFrom(this.runInstantQuery(query, options as any))\n      : await lastValueFrom(this.runRangeQuery(query, options as any));\n\n    const annotations: AnnotationEvent[] = [];\n    const splitKeys: string[] = tagKeys.split(',').filter((v: string) => v !== '');\n\n    for (const frame of data) {\n      const labels: { [key: string]: string } = {};\n      for (const field of frame.fields) {\n        if (field.labels) {\n          for (const [key, value] of Object.entries(field.labels)) {\n            labels[key] = String(value).trim();\n          }\n        }\n      }\n\n      const tags: string[] = [\n        ...new Set(\n          Object.entries(labels).reduce((acc: string[], [key, val]) => {\n            if (val === '') {\n              return acc;\n            }\n            if (splitKeys.length && !splitKeys.includes(key)) {\n              return acc;\n            }\n            acc.push.apply(acc, [val]);\n            return acc;\n          }, [])\n        ),\n      ];\n\n      const view = new DataFrameView<{ ts: string; line: string }>(frame);\n\n      view.forEach((row) => {\n        annotations.push({\n          time: new Date(row.ts).valueOf(),\n          title: renderTemplate(titleFormat, labels),\n          text: renderTemplate(textFormat, labels) || row.line,\n          tags,\n        });\n      });\n    }\n\n    return annotations;\n  }\n\n  showContextToggle(row?: LogRowModel): boolean {\n    return (row && row.searchWords && row.searchWords.length > 0) === true;\n  }\n\n  processError(err: FetchError, target: LokiQuery) {\n    let error = cloneDeep(err);\n    if (err.data.message.includes('escape') && target.expr.includes('\\\\')) {\n      error.data.message = `Error: ${err.data.message}. Make sure that all special characters are escaped with \\\\. For more information on escaping of special characters visit LogQL documentation at https://grafana.com/docs/loki/latest/logql/.`;\n    }\n    return error;\n  }\n\n  adjustInterval(dynamicInterval: number, resolution: number, range: number) {\n    // Loki will drop queries that might return more than 11000 data points.\n    // Calibrate interval if it is too small.\n    let safeInterval = range / 11000;\n    if (safeInterval > 1) {\n      safeInterval = Math.ceil(safeInterval);\n    }\n\n    let adjustedInterval = Math.max(resolution * dynamicInterval, safeInterval);\n    return adjustedInterval;\n  }\n\n  addAdHocFilters(queryExpr: string) {\n    const adhocFilters = this.templateSrv.getAdhocFilters(this.name);\n    let expr = queryExpr;\n\n    expr = adhocFilters.reduce((acc: string, filter: { key?: any; operator?: any; value?: any }) => {\n      const { key, operator } = filter;\n      let { value } = filter;\n      if (operator === '=~' || operator === '!~') {\n        value = lokiRegularEscape(value);\n      }\n\n      return this.addLabelToQuery(acc, key, value, operator, true);\n    }, expr);\n\n    return expr;\n  }\n\n  addLabelToQuery(\n    queryExpr: string,\n    key: string,\n    value: string | number,\n    operator: string,\n    // Override to make sure that we use label as actual label and not parsed label\n    notParsedLabelOverride?: boolean\n  ) {\n    if (queryHasPipeParser(queryExpr) && !isMetricsQuery(queryExpr) && !notParsedLabelOverride) {\n      // If query has parser, we treat all labels as parsed and use | key=\"value\" syntax\n      return addParsedLabelToQuery(queryExpr, key, value, operator);\n    } else {\n      return addLabelToQuery(queryExpr, key, value, operator, true);\n    }\n  }\n}\n\nexport function renderTemplate(aliasPattern: string, aliasData: { [key: string]: string }) {\n  const aliasRegex = /\\{\\{\\s*(.+?)\\s*\\}\\}/g;\n  return aliasPattern.replace(aliasRegex, (_match, g1) => {\n    if (aliasData[g1]) {\n      return aliasData[g1];\n    }\n    return '';\n  });\n}\n\nexport function lokiRegularEscape(value: any) {\n  if (typeof value === 'string') {\n    return value.replace(/'/g, \"\\\\\\\\'\");\n  }\n  return value;\n}\n\nexport function lokiSpecialRegexEscape(value: any) {\n  if (typeof value === 'string') {\n    return lokiRegularEscape(value.replace(/\\\\/g, '\\\\\\\\\\\\\\\\').replace(/[$^*{}\\[\\]+?.()|]/g, '\\\\\\\\$&'));\n  }\n  return value;\n}\n\n/**\n * Checks if the query expression uses function and so should return a time series instead of logs.\n * Sometimes important to know that before we actually do the query.\n */\nexport function isMetricsQuery(query: string): boolean {\n  const tokens = Prism.tokenize(query, syntax);\n  return tokens.some((t) => {\n    // Not sure in which cases it can be string maybe if nothing matched which means it should not be a function\n    return typeof t !== 'string' && t.type === 'function';\n  });\n}\n\nfunction extractLevel(dataFrame: DataFrame): LogLevel {\n  let valueField;\n  try {\n    valueField = new FieldCache(dataFrame).getFirstFieldOfType(FieldType.number);\n  } catch {}\n  return valueField?.labels ? getLogLevelFromLabels(valueField.labels) : LogLevel.unknown;\n}\n\nfunction getLogLevelFromLabels(labels: Labels): LogLevel {\n  const labelNames = ['level', 'lvl', 'loglevel'];\n  let levelLabel;\n  for (let labelName of labelNames) {\n    if (labelName in labels) {\n      levelLabel = labelName;\n      break;\n    }\n  }\n  return levelLabel ? getLogLevelFromKey(labels[levelLabel]) : LogLevel.unknown;\n}\n\nexport default LokiDatasource;\n","import React, { PureComponent } from 'react';\nimport { shuffle } from 'lodash';\nimport { QueryEditorHelpProps } from '@grafana/data';\nimport LokiLanguageProvider from '../language_provider';\nimport { LokiQuery } from '../types';\n\nconst DEFAULT_EXAMPLES = ['{job=\"default/prometheus\"}'];\nconst PREFERRED_LABELS = ['job', 'app', 'k8s_app'];\nconst EXAMPLES_LIMIT = 5;\n\nconst LOGQL_EXAMPLES = [\n  {\n    title: 'Log pipeline',\n    expression: '{job=\"mysql\"} |= \"metrics\" | logfmt | duration > 10s',\n    label:\n      'This query targets the MySQL job, filters out logs that don’t contain the word \"metrics\" and parses each log line to extract more labels and filters with them.',\n  },\n  {\n    title: 'Count over time',\n    expression: 'count_over_time({job=\"mysql\"}[5m])',\n    label: 'This query counts all the log lines within the last five minutes for the MySQL job.',\n  },\n  {\n    title: 'Rate',\n    expression: 'rate(({job=\"mysql\"} |= \"error\" != \"timeout\")[10s])',\n    label:\n      'This query gets the per-second rate of all non-timeout errors within the last ten seconds for the MySQL job.',\n  },\n  {\n    title: 'Aggregate, count, and group',\n    expression: 'sum(count_over_time({job=\"mysql\"}[5m])) by (level)',\n    label: 'Get the count of logs during the last five minutes, grouping by level.',\n  },\n];\n\nexport default class LokiCheatSheet extends PureComponent<QueryEditorHelpProps<LokiQuery>, { userExamples: string[] }> {\n  declare userLabelTimer: NodeJS.Timeout;\n  state = {\n    userExamples: [],\n  };\n\n  componentDidMount() {\n    this.scheduleUserLabelChecking();\n  }\n\n  componentWillUnmount() {\n    clearTimeout(this.userLabelTimer);\n  }\n\n  scheduleUserLabelChecking() {\n    this.userLabelTimer = setTimeout(this.checkUserLabels, 1000);\n  }\n\n  checkUserLabels = async () => {\n    // Set example from user labels\n    const provider: LokiLanguageProvider = this.props.datasource?.languageProvider;\n    if (provider.started) {\n      const labels = provider.getLabelKeys() || [];\n      const preferredLabel = PREFERRED_LABELS.find((l) => labels.includes(l));\n      if (preferredLabel) {\n        const values = await provider.getLabelValues(preferredLabel);\n        const userExamples = shuffle(values)\n          .slice(0, EXAMPLES_LIMIT)\n          .map((value) => `{${preferredLabel}=\"${value}\"}`);\n        this.setState({ userExamples });\n      }\n    } else {\n      this.scheduleUserLabelChecking();\n    }\n  };\n\n  renderExpression(expr: string) {\n    const { onClickExample } = this.props;\n\n    return (\n      <div className=\"cheat-sheet-item__example\" key={expr} onClick={(e) => onClickExample({ refId: 'A', expr })}>\n        <code>{expr}</code>\n      </div>\n    );\n  }\n\n  render() {\n    const { userExamples } = this.state;\n    const hasUserExamples = userExamples.length > 0;\n\n    return (\n      <div>\n        <h2>Loki Cheat Sheet</h2>\n        <div className=\"cheat-sheet-item\">\n          <div className=\"cheat-sheet-item__title\">See your logs</div>\n          <div className=\"cheat-sheet-item__label\">\n            Start by selecting a log stream from the Log browser, or alternatively you can write a stream selector into\n            the query field.\n          </div>\n          {hasUserExamples ? (\n            <div>\n              <div className=\"cheat-sheet-item__label\">Here are some example streams from your logs:</div>\n              {userExamples.map((example) => this.renderExpression(example))}\n            </div>\n          ) : (\n            <div>\n              <div className=\"cheat-sheet-item__label\">Here is an example of a log stream:</div>\n              {this.renderExpression(DEFAULT_EXAMPLES[0])}\n            </div>\n          )}\n        </div>\n        <div className=\"cheat-sheet-item\">\n          <div className=\"cheat-sheet-item__title\">Combine stream selectors</div>\n          {this.renderExpression('{app=\"cassandra\",namespace=\"prod\"}')}\n          <div className=\"cheat-sheet-item__label\">Returns all log lines from streams that have both labels.</div>\n        </div>\n\n        <div className=\"cheat-sheet-item\">\n          <div className=\"cheat-sheet-item__title\">Filtering for search terms.</div>\n          {this.renderExpression('{app=\"cassandra\"} |~ \"(duration|latency)s*(=|is|of)s*[d.]+\"')}\n          {this.renderExpression('{app=\"cassandra\"} |= \"exact match\"')}\n          {this.renderExpression('{app=\"cassandra\"} != \"do not match\"')}\n          <div className=\"cheat-sheet-item__label\">\n            <a href=\"https://grafana.com/docs/loki/latest/logql/#log-pipeline\" target=\"logql\">\n              LogQL\n            </a>{' '}\n            supports exact and regular expression filters.\n          </div>\n        </div>\n        {LOGQL_EXAMPLES.map((item) => (\n          <div className=\"cheat-sheet-item\" key={item.expression}>\n            <div className=\"cheat-sheet-item__title\">{item.title}</div>\n            {this.renderExpression(item.expression)}\n            <div className=\"cheat-sheet-item__label\">{item.label}</div>\n          </div>\n        ))}\n      </div>\n    );\n  }\n}\n","// Libraries\nimport React, { memo } from 'react';\n\n// Types\nimport { QueryEditorProps } from '@grafana/data';\nimport { LokiDatasource } from '../datasource';\nimport { LokiQuery, LokiOptions } from '../types';\nimport { LokiQueryField } from './LokiQueryField';\nimport { LokiOptionFields } from './LokiOptionFields';\n\ntype Props = QueryEditorProps<LokiDatasource, LokiQuery, LokiOptions>;\n\nexport function LokiExploreQueryEditor(props: Props) {\n  const { query, data, datasource, history, onChange, onRunQuery, range } = props;\n\n  return (\n    <LokiQueryField\n      datasource={datasource}\n      query={query}\n      onChange={onChange}\n      onBlur={() => {}}\n      onRunQuery={onRunQuery}\n      history={history}\n      data={data}\n      range={range}\n      ExtraFieldElement={\n        <LokiOptionFields\n          queryType={query.instant ? 'instant' : 'range'}\n          lineLimitValue={query?.maxLines?.toString() || ''}\n          resolution={query.resolution || 1}\n          query={query}\n          onRunQuery={onRunQuery}\n          onChange={onChange}\n        />\n      }\n    />\n  );\n}\n\nexport default memo(LokiExploreQueryEditor);\n","// Libraries\nimport React from 'react';\n\n// Types\nimport { InlineFormLabel } from '@grafana/ui';\nimport { LokiQueryField } from './LokiQueryField';\nimport { LokiOptionFields } from './LokiOptionFields';\nimport { LokiQueryEditorProps } from './types';\n\nexport function LokiQueryEditor(props: LokiQueryEditorProps) {\n  const { query, data, datasource, onChange, onRunQuery, range } = props;\n\n  const onLegendChange = (e: React.SyntheticEvent<HTMLInputElement>) => {\n    const nextQuery = { ...query, legendFormat: e.currentTarget.value };\n    onChange(nextQuery);\n  };\n\n  const legendField = (\n    <div className=\"gf-form-inline\">\n      <div className=\"gf-form\">\n        <InlineFormLabel\n          width={6}\n          tooltip=\"Controls the name of the time series, using name or pattern. For example\n        {{hostname}} will be replaced with label value for the label hostname. The legend only applies to metric queries.\"\n        >\n          Legend\n        </InlineFormLabel>\n        <input\n          type=\"text\"\n          className=\"gf-form-input\"\n          placeholder=\"legend format\"\n          value={query.legendFormat || ''}\n          onChange={onLegendChange}\n          onBlur={onRunQuery}\n        />\n      </div>\n    </div>\n  );\n\n  return (\n    <LokiQueryField\n      datasource={datasource}\n      query={query}\n      onChange={onChange}\n      onRunQuery={onRunQuery}\n      onBlur={onRunQuery}\n      history={[]}\n      data={data}\n      data-testid={testIds.editor}\n      range={range}\n      ExtraFieldElement={\n        <>\n          <LokiOptionFields\n            queryType={query.instant ? 'instant' : 'range'}\n            lineLimitValue={query?.maxLines?.toString() || ''}\n            resolution={query?.resolution || 1}\n            query={query}\n            onRunQuery={onRunQuery}\n            onChange={onChange}\n            runOnBlur={true}\n          />\n          {legendField}\n        </>\n      }\n    />\n  );\n}\n\nexport const testIds = {\n  editor: 'loki-editor',\n};\n","import React from 'react';\nimport { LokiQueryField } from './LokiQueryField';\nimport { LokiQueryEditorProps } from './types';\n\nexport function LokiQueryEditorForAlerting(props: LokiQueryEditorProps) {\n  const { query, data, datasource, onChange, onRunQuery } = props;\n\n  return (\n    <LokiQueryField\n      datasource={datasource}\n      query={query}\n      onChange={onChange}\n      onRunQuery={onRunQuery}\n      onBlur={onRunQuery}\n      history={[]}\n      data={data}\n      placeholder=\"Enter a Loki query\"\n      data-testid={testIds.editor}\n    />\n  );\n}\n\nexport const testIds = {\n  editor: 'loki-editor-cloud-alerting',\n};\n","import React, { memo } from 'react';\nimport { CoreApp } from '@grafana/data';\nimport { LokiQueryEditorProps } from './types';\nimport { LokiQueryEditor } from './LokiQueryEditor';\nimport { LokiQueryEditorForAlerting } from './LokiQueryEditorForAlerting';\n\nexport function LokiQueryEditorByApp(props: LokiQueryEditorProps) {\n  const { app } = props;\n\n  switch (app) {\n    case CoreApp.CloudAlerting:\n      return <LokiQueryEditorForAlerting {...props} />;\n    default:\n      return <LokiQueryEditor {...props} />;\n  }\n}\n\nexport default memo(LokiQueryEditorByApp);\n","import { LokiQuery } from './types';\n/**\n * Just a simple wrapper for a react component that is actually implementing the query editor.\n */\nexport class LokiAnnotationsQueryCtrl {\n  static templateUrl = 'partials/annotations.editor.html';\n  declare annotation: any;\n\n  /** @ngInject */\n  constructor($scope: any) {\n    this.annotation = $scope.ctrl.annotation;\n    this.annotation.target = this.annotation.target || {};\n    this.onQueryChange = this.onQueryChange.bind(this);\n  }\n\n  onQueryChange(query: LokiQuery) {\n    this.annotation.expr = query.expr;\n    this.annotation.maxLines = query.maxLines;\n    this.annotation.instant = query.instant;\n  }\n}\n","import React from 'react';\nimport { LegacyForms } from '@grafana/ui';\nconst { FormField } = LegacyForms;\n\ntype Props = {\n  value: string;\n  onChange: (value: string) => void;\n};\n\nexport const MaxLinesField = (props: Props) => {\n  const { value, onChange } = props;\n  return (\n    <FormField\n      label=\"Maximum lines\"\n      labelWidth={11}\n      inputWidth={20}\n      inputEl={\n        <input\n          type=\"number\"\n          className=\"gf-form-input width-8 gf-form-input--has-help-icon\"\n          value={value}\n          onChange={(event) => onChange(event.currentTarget.value)}\n          spellCheck={false}\n          placeholder=\"1000\"\n        />\n      }\n      tooltip={\n        <>\n          Loki queries must contain a limit of the maximum number of lines returned (default: 1000). Increase this limit\n          to have a bigger result set for ad-hoc analysis. Decrease this limit if your browser becomes sluggish when\n          displaying the log results.\n        </>\n      }\n    />\n  );\n};\n","import React, { useEffect, useState } from 'react';\nimport { css } from '@emotion/css';\nimport { Button, DataLinkInput, stylesFactory, LegacyForms } from '@grafana/ui';\nimport { VariableSuggestion } from '@grafana/data';\nimport { DataSourcePicker } from '@grafana/runtime';\nimport { DerivedFieldConfig } from '../types';\nimport { usePrevious } from 'react-use';\n\nconst { Switch, FormField } = LegacyForms;\n\nconst getStyles = stylesFactory(() => ({\n  row: css`\n    display: flex;\n    align-items: baseline;\n  `,\n  nameField: css`\n    flex: 2;\n  `,\n  regexField: css`\n    flex: 3;\n  `,\n  urlField: css`\n    flex: 1;\n  `,\n  urlDisplayLabelField: css`\n    flex: 1;\n  `,\n}));\n\ntype Props = {\n  value: DerivedFieldConfig;\n  onChange: (value: DerivedFieldConfig) => void;\n  onDelete: () => void;\n  suggestions: VariableSuggestion[];\n  className?: string;\n};\nexport const DerivedField = (props: Props) => {\n  const { value, onChange, onDelete, suggestions, className } = props;\n  const styles = getStyles();\n  const [showInternalLink, setShowInternalLink] = useState(!!value.datasourceUid);\n  const previousUid = usePrevious(value.datasourceUid);\n\n  // Force internal link visibility change if uid changed outside of this component.\n  useEffect(() => {\n    if (!previousUid && value.datasourceUid && !showInternalLink) {\n      setShowInternalLink(true);\n    }\n    if (previousUid && !value.datasourceUid && showInternalLink) {\n      setShowInternalLink(false);\n    }\n  }, [previousUid, value.datasourceUid, showInternalLink]);\n\n  const handleChange = (field: keyof typeof value) => (event: React.ChangeEvent<HTMLInputElement>) => {\n    onChange({\n      ...value,\n      [field]: event.currentTarget.value,\n    });\n  };\n\n  return (\n    <div className={className}>\n      <div className={styles.row}>\n        <FormField\n          className={styles.nameField}\n          labelWidth={5}\n          // A bit of a hack to prevent using default value for the width from FormField\n          inputWidth={null}\n          label=\"Name\"\n          type=\"text\"\n          value={value.name}\n          onChange={handleChange('name')}\n        />\n        <FormField\n          className={styles.regexField}\n          inputWidth={null}\n          label=\"Regex\"\n          type=\"text\"\n          value={value.matcherRegex}\n          onChange={handleChange('matcherRegex')}\n          tooltip={\n            'Use to parse and capture some part of the log message. You can use the captured groups in the template.'\n          }\n        />\n        <Button\n          variant=\"destructive\"\n          title=\"Remove field\"\n          icon=\"times\"\n          onClick={(event) => {\n            event.preventDefault();\n            onDelete();\n          }}\n          className={css`\n            margin-left: 8px;\n          `}\n        />\n      </div>\n\n      <div className={styles.row}>\n        <FormField\n          label={showInternalLink ? 'Query' : 'URL'}\n          inputEl={\n            <DataLinkInput\n              placeholder={showInternalLink ? '${__value.raw}' : 'http://example.com/${__value.raw}'}\n              value={value.url || ''}\n              onChange={(newValue) =>\n                onChange({\n                  ...value,\n                  url: newValue,\n                })\n              }\n              suggestions={suggestions}\n            />\n          }\n          className={styles.urlField}\n        />\n        <FormField\n          className={styles.urlDisplayLabelField}\n          inputWidth={null}\n          label=\"URL Label\"\n          type=\"text\"\n          value={value.urlDisplayLabel}\n          onChange={handleChange('urlDisplayLabel')}\n          tooltip={'Use to override the button label when this derived field is found in a log.'}\n        />\n      </div>\n\n      <div className={styles.row}>\n        <Switch\n          label=\"Internal link\"\n          checked={showInternalLink}\n          onChange={() => {\n            if (showInternalLink) {\n              onChange({\n                ...value,\n                datasourceUid: undefined,\n              });\n            }\n            setShowInternalLink(!showInternalLink);\n          }}\n        />\n\n        {showInternalLink && (\n          <DataSourcePicker\n            tracing={true}\n            onChange={(ds) =>\n              onChange({\n                ...value,\n                datasourceUid: ds.uid,\n              })\n            }\n            current={value.datasourceUid}\n          />\n        )}\n      </div>\n    </div>\n  );\n};\n","import React, { useState } from 'react';\nimport { css } from '@emotion/css';\nimport cx from 'classnames';\nimport { LegacyForms } from '@grafana/ui';\nconst { FormField } = LegacyForms;\nimport { DerivedFieldConfig } from '../types';\nimport { ArrayVector, Field, FieldType, LinkModel } from '@grafana/data';\nimport { getFieldLinksForExplore } from '../../../../features/explore/utils/links';\n\ntype Props = {\n  derivedFields?: DerivedFieldConfig[];\n  className?: string;\n};\nexport const DebugSection = (props: Props) => {\n  const { derivedFields, className } = props;\n  const [debugText, setDebugText] = useState('');\n\n  let debugFields: DebugField[] = [];\n  if (debugText && derivedFields) {\n    debugFields = makeDebugFields(derivedFields, debugText);\n  }\n\n  return (\n    <div className={className}>\n      <FormField\n        labelWidth={12}\n        label={'Debug log message'}\n        inputEl={\n          <textarea\n            placeholder={'Paste an example log line here to test the regular expressions of your derived fields'}\n            className={cx(\n              'gf-form-input gf-form-textarea',\n              css`\n                width: 100%;\n              `\n            )}\n            value={debugText}\n            onChange={(event) => setDebugText(event.currentTarget.value)}\n          />\n        }\n      />\n      {!!debugFields.length && <DebugFields fields={debugFields} />}\n    </div>\n  );\n};\n\ntype DebugFieldItemProps = {\n  fields: DebugField[];\n};\nconst DebugFields = ({ fields }: DebugFieldItemProps) => {\n  return (\n    <table className={'filter-table'}>\n      <thead>\n        <tr>\n          <th>Name</th>\n          <th>Value</th>\n          <th>Url</th>\n        </tr>\n      </thead>\n      <tbody>\n        {fields.map((field) => {\n          let value: any = field.value;\n          if (field.error) {\n            value = field.error.message;\n          } else if (field.href) {\n            value = <a href={field.href}>{value}</a>;\n          }\n          return (\n            <tr key={`${field.name}=${field.value}`}>\n              <td>{field.name}</td>\n              <td>{value}</td>\n              <td>{field.href ? <a href={field.href}>{field.href}</a> : ''}</td>\n            </tr>\n          );\n        })}\n      </tbody>\n    </table>\n  );\n};\n\ntype DebugField = {\n  name: string;\n  error?: any;\n  value?: string;\n  href?: string;\n};\n\nfunction makeDebugFields(derivedFields: DerivedFieldConfig[], debugText: string): DebugField[] {\n  return derivedFields\n    .filter((field) => field.name && field.matcherRegex)\n    .map((field) => {\n      try {\n        const testMatch = debugText.match(field.matcherRegex);\n        const value = testMatch && testMatch[1];\n        let link: LinkModel<Field> | null = null;\n\n        if (field.url && value) {\n          link = getFieldLinksForExplore({\n            field: {\n              name: '',\n              type: FieldType.string,\n              values: new ArrayVector([value]),\n              config: {\n                links: [{ title: '', url: field.url }],\n              },\n            },\n            rowIndex: 0,\n            range: {} as any,\n          })[0];\n        }\n\n        return {\n          name: field.name,\n          value: value || '<no match>',\n          href: link && link.href,\n        } as DebugField;\n      } catch (error) {\n        return {\n          name: field.name,\n          error,\n        } as DebugField;\n      }\n    });\n}\n","import React, { useState } from 'react';\nimport { css } from '@emotion/css';\nimport { Button, useTheme2 } from '@grafana/ui';\nimport { GrafanaTheme2, VariableOrigin, DataLinkBuiltInVars } from '@grafana/data';\nimport { DerivedFieldConfig } from '../types';\nimport { DerivedField } from './DerivedField';\nimport { DebugSection } from './DebugSection';\n\nconst getStyles = (theme: GrafanaTheme2) => ({\n  infoText: css`\n    padding-bottom: ${theme.spacing(2)};\n    color: ${theme.colors.text.secondary};\n  `,\n  derivedField: css`\n    margin-bottom: ${theme.spacing(1)};\n  `,\n});\n\ntype Props = {\n  value?: DerivedFieldConfig[];\n  onChange: (value: DerivedFieldConfig[]) => void;\n};\n\nexport const DerivedFields = (props: Props) => {\n  const { value, onChange } = props;\n  const theme = useTheme2();\n  const styles = getStyles(theme);\n\n  const [showDebug, setShowDebug] = useState(false);\n\n  return (\n    <>\n      <h3 className=\"page-heading\">Derived fields</h3>\n\n      <div className={styles.infoText}>\n        Derived fields can be used to extract new fields from a log message and create a link from its value.\n      </div>\n\n      <div className=\"gf-form-group\">\n        {value &&\n          value.map((field, index) => {\n            return (\n              <DerivedField\n                className={styles.derivedField}\n                key={index}\n                value={field}\n                onChange={(newField) => {\n                  const newDerivedFields = [...value];\n                  newDerivedFields.splice(index, 1, newField);\n                  onChange(newDerivedFields);\n                }}\n                onDelete={() => {\n                  const newDerivedFields = [...value];\n                  newDerivedFields.splice(index, 1);\n                  onChange(newDerivedFields);\n                }}\n                suggestions={[\n                  {\n                    value: DataLinkBuiltInVars.valueRaw,\n                    label: 'Raw value',\n                    documentation: 'Exact string captured by the regular expression',\n                    origin: VariableOrigin.Value,\n                  },\n                ]}\n              />\n            );\n          })}\n        <div>\n          <Button\n            variant=\"secondary\"\n            className={css`\n              margin-right: 10px;\n            `}\n            icon=\"plus\"\n            onClick={(event) => {\n              event.preventDefault();\n              const newDerivedFields = [...(value || []), { name: '', matcherRegex: '' }];\n              onChange(newDerivedFields);\n            }}\n          >\n            Add\n          </Button>\n\n          {value && value.length > 0 && (\n            <Button variant=\"secondary\" type=\"button\" onClick={() => setShowDebug(!showDebug)}>\n              {showDebug ? 'Hide example log message' : 'Show example log message'}\n            </Button>\n          )}\n        </div>\n      </div>\n\n      {showDebug && (\n        <div className=\"gf-form-group\">\n          <DebugSection\n            className={css`\n              margin-bottom: 10px;\n            `}\n            derivedFields={value}\n          />\n        </div>\n      )}\n    </>\n  );\n};\n","import React from 'react';\nimport { DataSourcePluginOptionsEditorProps, DataSourceSettings } from '@grafana/data';\nimport { AlertingSettings, DataSourceHttpSettings } from '@grafana/ui';\nimport { LokiOptions } from '../types';\nimport { MaxLinesField } from './MaxLinesField';\nimport { DerivedFields } from './DerivedFields';\nimport { getAllAlertmanagerDataSources } from 'app/features/alerting/unified/utils/alertmanager';\n\nexport type Props = DataSourcePluginOptionsEditorProps<LokiOptions>;\n\nconst makeJsonUpdater = <T extends any>(field: keyof LokiOptions) => (\n  options: DataSourceSettings<LokiOptions>,\n  value: T\n): DataSourceSettings<LokiOptions> => {\n  return {\n    ...options,\n    jsonData: {\n      ...options.jsonData,\n      [field]: value,\n    },\n  };\n};\n\nconst setMaxLines = makeJsonUpdater('maxLines');\nconst setDerivedFields = makeJsonUpdater('derivedFields');\n\nexport const ConfigEditor = (props: Props) => {\n  const { options, onOptionsChange } = props;\n  const alertmanagers = getAllAlertmanagerDataSources();\n\n  return (\n    <>\n      <DataSourceHttpSettings\n        defaultUrl={'http://localhost:3100'}\n        dataSourceConfig={options}\n        showAccessOptions={false}\n        onChange={onOptionsChange}\n      />\n\n      <AlertingSettings<LokiOptions>\n        alertmanagerDataSources={alertmanagers}\n        options={options}\n        onOptionsChange={onOptionsChange}\n      />\n\n      <div className=\"gf-form-group\">\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <MaxLinesField\n              value={options.jsonData.maxLines || ''}\n              onChange={(value) => onOptionsChange(setMaxLines(options, value))}\n            />\n          </div>\n        </div>\n      </div>\n\n      <DerivedFields\n        value={options.jsonData.derivedFields}\n        onChange={(value) => onOptionsChange(setDerivedFields(options, value))}\n      />\n    </>\n  );\n};\n","import { DataSourcePlugin } from '@grafana/data';\nimport Datasource from './datasource';\n\nimport LokiCheatSheet from './components/LokiCheatSheet';\nimport LokiExploreQueryEditor from './components/LokiExploreQueryEditor';\nimport LokiQueryEditorByApp from './components/LokiQueryEditorByApp';\nimport { LokiAnnotationsQueryCtrl } from './LokiAnnotationsQueryCtrl';\nimport { ConfigEditor } from './configuration/ConfigEditor';\n\nexport const plugin = new DataSourcePlugin(Datasource)\n  .setQueryEditor(LokiQueryEditorByApp)\n  .setConfigEditor(ConfigEditor)\n  .setExploreQueryField(LokiExploreQueryEditor)\n  .setQueryEditorHelp(LokiCheatSheet)\n  .setAnnotationQueryCtrl(LokiAnnotationsQueryCtrl);\n"],"names":["builtInWords","PROM_KEYWORDS","OPERATORS","LOGICAL_OPERATORS","LOKI_KEYWORDS","metricsAndKeywordsRegexp","addLabelToQuery","query","key","value","operator","hasNoMetrics","Error","transformedValue","Infinity","toString","previousWord","replace","match","word","offset","isMetric","insideSelector","text","position","openChar","closeChar","nextSelectorStart","slice","indexOf","nextSelectorEnd","isPositionInsideChars","previousWordIsKeyWord","isColonBounded","endsWith","startsWithQuote","isTemplateVariable","isTimeUnit","includes","Boolean","Number","isWordMetric","selectorRegexp","parts","lastIndex","suffix","exec","prefix","index","length","startsWith","push","selectorWithLabel","addLabelToSelector","join","labelRegexp","selector","labelKey","labelValue","labelOperator","parsedLabels","operatorForLabelKey","chain","uniqWith","isEqual","compact","sortBy","map","uuid","validate","TypeError","v","arr","Uint8Array","parseInt","f","s","x","y","z","ROTL","n","v5","name","version","hashfunc","generateUUID","namespace","buf","str","unescape","encodeURIComponent","bytes","i","charCodeAt","stringToBytes","set","stringify","err","DNS","URL","v35","K","H","msg","Array","isArray","prototype","call","l","N","Math","ceil","M","_i","Uint32Array","j","pow","floor","_i2","W","t","_t","a","b","c","d","e","_t2","T","formatQuery","trim","getHighlighterExpressionsFromQuery","input","expression","results","filterStart","search","filterOperator","substr","skip","filterEnd","filterTerm","quotedTerm","backtickedTerm","term","unwrappedFilterTerm","escapeRegExp","LokiResultType","lokiStreamResultToDataFrame","stream","reverse","refId","labels","labelsString","Object","entries","val","sort","times","ArrayVector","timesNs","lines","uids","usedUids","ts","line","values","add","Date","toISOString","createUid","dataFrame","fields","type","FieldType","config","displayName","mutableDataFrame","MutableDataFrame","constructDataFrame","id","uuidv5","newCount","lokiMatrixToTimeSeries","matrixResult","options","labelData","label","undefined","isEmpty","legendFormat","metricName","__name__","labelPart","getOriginalMetricName","aliasPattern","aliasData","aliasRegex","_","g1","renderTemplate","getTemplateSrv","scopedVars","createMetricLabel","metric","target","title","datapoints","lokiPointsToTimeseriesPoints","tags","meta","data","stepMs","step","baseTimestampMs","start","time","datapointValue","parseFloat","isNaN","timestamp","endTimestamp","end","lokiResultsToTableModel","lokiResults","resultCount","valueWithRefId","TableModel","sortedLabels","Set","reduce","acc","cur","concat","keys","table","columns","filterable","forEach","series","newSeries","rows","lokiStatsToMetaStat","stats","result","section","unit","test","capitalize","m","toLowerCase","lokiStreamsToDataFrames","response","limit","custom","lokiQueryStatKey","searchWords","expr","preferredVisualisationType","enhanceDataFrame","some","error","derivedFields","derivedFieldsGrouped","groupBy","newFields","fieldFromDerivedFieldConfig","DataFrameView","row","field","logMatch","matcherRegex","derivedFieldConfigs","dataSourceSrv","getDataSourceSrv","dataLinks","derivedFieldConfig","datasourceUid","dsSettings","getInstanceSettings","urlDisplayLabel","url","internal","datasourceName","links","rangeQueryResponseToTimeSeries","responseListLength","transformerOptions","format","resultType","Vector","vecResult","Matrix","processRangeQueryResponse","Stream","of","DEFAULT_WEBSOCKET_CONFIG","deserializer","JSON","parse","serializer","WebSocketSubject","_super","urlConfigOrSource","destination","_this","this","_socket","Observable","source","_config","_output","Subject","hasOwnProperty","WebSocketCtor","WebSocket","ReplaySubject","lift","sock","_resetState","multiplex","subMsg","unsubMsg","messageFilter","self","observer","next","subscription","subscribe","complete","unsubscribe","_connectSocket","_a","protocol","binaryType","socket","Subscription","readyState","close","onopen","evt","openObserver","queue","Subscriber","send","closingObserver","code","reason","onerror","onclose","closeObserver","wasClean","onmessage","_subscribe","subscriber","observers","LiveStreams","getStream","retryInterval","streams","CircularDataFrame","capacity","size","addField","parseLabels","pipe","baseLabels","tsField","tsNsField","lineField","labelsField","idField","unique","findUniqueLabels","allLabelsString","appendResponseToBufferedData","retryWhen","attempts","mergeMap","retryAttempt","console","warn","timer","throwError","finalize","DEFAULT_KEYS","EMPTY_SELECTOR","RATE_RANGES","sortValue","wrapLabel","filterText","LokiLanguageProvider","LanguageProvider","constructor","datasource","initialValues","super","LRU","async","params","metadataRequest","startTask","fetchLabels","then","started","context","suggestions","getEmptyCompletionItems","getTermCompletionItems","prefixMatch","items","FUNCTIONS","suggestion","kind","PIPE_OPERATORS","PIPE_PARSERS","getTimeRangeParams","cacheKey","generateCacheKey","seriesCache","get","request","processLabels","labelKeys","labelFetchTs","assign","getSyntax","syntax","getLabelKeys","wrapperClasses","emptyResult","empty","document","selectedLines","getTextsAtRange","selection","currentLine","first","getText","nextCharacter","anchor","tokenRecognized","prefixUnrecognized","noSuffix","safePrefix","isNextOperand","getRangeCompletionItems","getLabelCompletionItems","getPipeCompletionItem","getBeginningCompletionItems","history","historyItems","h","filter","uniq","take","item","cutoffTs","now","historyForItem","hint","recent","dateTime","fromNow","documentation","addHistoryMetadata","skipSort","anchorBlock","cursorOffset","isValueStart","parsedSelector","parseSelector","existingKeys","labelValues","getLabelValues","getSeriesLabels","possibleKeys","difference","newSuggestion","importFromAbstractQuery","labelBasedQuery","toPromLikeQuery","exportToAbstractQuery","lokiQuery","labelMatchers","tokens","Prism","extractLabelMatchers","lookupsDisabled","fetchSeriesLabels","timeRange","valueOf","res","forceRefresh","param","roundTime","nanos","fetchLabelValues","rangeParams","labelsCache","NS_IN_MS","RANGE_QUERY_ENDPOINT","INSTANT_QUERY_ENDPOINT","DEFAULT_QUERY_PARAMS","direction","LokiDatasource","DataSourceApi","instanceSettings","templateSrv","timeSrv","getTimeSrv","timeNs","getTime","range","to","queryLimit","isMetricsQuery","maxDataPoints","maxLines","min","_request","jsonData","catchError","processError","liveStreaming","runLiveQuery","createRangeQuery","headers","volumeQuery","switchMap","liveTarget","createLiveTarget","state","LoadingState","prepareLogRowContextQueryTarget","lastValueFrom","message","status","statusText","languageProvider","contextTimeBuffer","commonTargetOptions","nsTimestamp","FieldCache","getFieldByName","rowIndex","timeEpochMs","settingsData","apiUrl","baseUrl","serializeParams","withCredentials","basicAuth","Authorization","req","getBackendSrv","fetch","getLogsVolumeDataProvider","targets","logsVolumeRequest","cloneDeep","instant","queryLogsVolume","timeout","extractLevel","subQueries","getRangeScopedVars","filteredTargets","hide","addAdHocFilters","interpolateQueryExpr","runInstantQuery","runRangeQuery","merge","startNs","from","endNs","rangeMs","resolution","DEFAULT_RESOLUTION","adjustedInterval","adjustInterval","intervalMs","convertToWebSocketUrl","msRange","diff","sRange","round","__range_ms","__range_s","__range","interpolateVariablesInQueries","queries","expandedQueries","getRef","getQueryDisplayText","abstractQueries","abstractQuery","labelMatcher","hideFromInspector","Promise","resolve","interpolated","processMetricFindQuery","labelNamesQuery","labelValuesSeriesQuery","labelValuesQuery","timeParams","variable","multi","includeAll","lokiRegularEscape","lokiSpecialRegexEscape","lodashMap","modifyQuery","action","date","roundUp","dateMath","testDatasource","stepInterval","tagKeys","titleFormat","textFormat","annotation","interpolatedExpr","annotations","splitKeys","split","frame","String","apply","showContextToggle","dynamicInterval","safeInterval","max","queryExpr","getAdhocFilters","notParsedLabelOverride","parsers","parser","RegExp","queryHasPipeParser","addParsedLabelToQuery","_match","valueField","getFirstFieldOfType","labelNames","levelLabel","labelName","getLogLevelFromKey","LogLevel","getLogLevelFromLabels","DEFAULT_EXAMPLES","PREFERRED_LABELS","LOGQL_EXAMPLES","LokiCheatSheet","PureComponent","userExamples","provider","props","preferredLabel","find","shuffle","setState","scheduleUserLabelChecking","componentDidMount","componentWillUnmount","clearTimeout","userLabelTimer","setTimeout","checkUserLabels","renderExpression","onClickExample","className","onClick","render","hasUserExamples","example","href","LokiExploreQueryEditor","onChange","onRunQuery","LokiQueryField","onBlur","ExtraFieldElement","LokiOptionFields","queryType","lineLimitValue","memo","LokiQueryEditor","legendField","InlineFormLabel","width","tooltip","placeholder","nextQuery","currentTarget","testIds","editor","runOnBlur","LokiQueryEditorForAlerting","LokiQueryEditorByApp","app","CoreApp","LokiAnnotationsQueryCtrl","$scope","ctrl","onQueryChange","bind","FormField","LegacyForms","MaxLinesField","labelWidth","inputWidth","inputEl","event","spellCheck","Switch","getStyles","stylesFactory","css","nameField","regexField","urlField","urlDisplayLabelField","DerivedField","onDelete","styles","showInternalLink","setShowInternalLink","useState","previousUid","usePrevious","useEffect","handleChange","Button","variant","icon","preventDefault","DataLinkInput","newValue","checked","DataSourcePicker","tracing","ds","uid","current","DebugSection","debugText","setDebugText","debugFields","testMatch","link","getFieldLinksForExplore","makeDebugFields","cx","DebugFields","DerivedFields","theme","infoText","spacing","colors","secondary","derivedField","useTheme2","showDebug","setShowDebug","newField","newDerivedFields","splice","DataLinkBuiltInVars","origin","VariableOrigin","makeJsonUpdater","setMaxLines","setDerivedFields","plugin","DataSourcePlugin","Datasource","setQueryEditor","setConfigEditor","onOptionsChange","alertmanagers","getAllAlertmanagerDataSources","DataSourceHttpSettings","defaultUrl","dataSourceConfig","showAccessOptions","AlertingSettings","alertmanagerDataSources","setExploreQueryField","setQueryEditorHelp","setAnnotationQueryCtrl"],"sourceRoot":""}